<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mosaik</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Developer documentation for mosaik — a Rust runtime for building self-organizing, leaderless distributed systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b8260048.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-afb5d9f0.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Mosaik</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/flashbots/mosaik" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Mosaik</strong> is a Rust runtime for building <strong>self-organizing, leaderless distributed systems</strong>. It is designed for trusted, permissioned networks — environments where all participating nodes are assumed honest, such as L2 blockchain infrastructure operated by a single organization.</p>
<h2 id="what-mosaik-does"><a class="header" href="#what-mosaik-does">What Mosaik Does</a></h2>
<p>When you deploy mosaik-based binaries on arbitrary machines, the network <strong>self-organizes</strong>: nodes discover each other via gossip, infer the data-flow topology, elect leaders where needed, and converge to a stable operational state. Each node needs only two things to participate:</p>
<ol>
<li><strong>A network ID</strong> — identifies which logical network to join</li>
<li>** (optionally) A bootstrap peer** — the peer ID of any node already on the network (the <a href="https://github.com/flashbots/mosaik/blob/main/examples/bootstrap.rs">bootstrap example</a> can be used in production as a universal bootstrap node). Mosaik provides automatic bootstrap by publishing peer identities and their network id associations in Mainline DHT for zero-config discovery.</li>
</ol>
<p>A secret key is automatically generated on each run, giving the node a unique identity. Specifying a fixed secret key is only recommended for bootstrap nodes that need a stable, well-known peer ID across restarts.</p>
<p>From these minimal inputs, mosaik handles peer discovery, typed pub/sub data streaming, Raft-based consensus groups, and replicated data structures — all automatically.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<ul>
<li><strong>Not Byzantine fault tolerant.</strong> All members are assumed honest. This simplifies the protocol stack and enables higher throughput compared to BFT systems.</li>
<li><strong>Self-organizing.</strong> No central coordinator, no manual topology configuration. Nodes find each other and form the right connections.</li>
<li><strong>Built on modern networking.</strong> Uses <a href="https://github.com/n0-computer/iroh">iroh</a> for QUIC-based peer-to-peer transport with relay support and hole-punching.</li>
<li><strong>Composable primitives.</strong> Five subsystems (<code>Network</code>, <code>Discovery</code>, <code>Streams</code>, <code>Groups</code>, <code>Collections</code>) compose to support a wide range of distributed application patterns.</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────────────┐
│                   Network                       │
│  (QUIC endpoint, identity, protocol routing)    │
├──────────┬──────────┬──────────┬────────────────┤
│ Discovery│ Streams  │  Groups  │  Collections   │
│  gossip, │  typed   │   Raft   │  Map/Vec/Set/  │
│  catalog │ pub/sub  │ consensus│ PriorityQueue  │
│          │          │  groups  │                │
└──────────┴──────────┴──────────┴────────────────┘
</code></pre>
<ul>
<li><strong>Network</strong> is the entry point. It manages the QUIC transport, node identity, and composes all subsystems.</li>
<li><strong>Discovery</strong> uses gossip to maintain a catalog of all peers, their capabilities, and their available streams/groups.</li>
<li><strong>Streams</strong> provides typed, async pub/sub channels. Any serializable Rust type can be streamed between nodes.</li>
<li><strong>Groups</strong> implements Raft consensus for clusters of nodes that need shared state and leader election.</li>
<li><strong>Collections</strong> builds on Groups to offer replicated data structures (<code>Map</code>, <code>Vec</code>, <code>Set</code>, <code>PriorityQueue</code>) that stay synchronized across nodes.</li>
</ul>
<h2 id="who-should-read-this-book"><a class="header" href="#who-should-read-this-book">Who Should Read This Book</a></h2>
<p>This book serves two audiences:</p>
<ul>
<li><strong>Application developers</strong> building distributed systems with mosaik — start with <a href="#overview">Getting Started</a> and the <a href="#building-a-bootstrap-node">Tutorials</a>.</li>
<li><strong>Contributors</strong> to mosaik itself — the <a href="#raft-consensus">Architecture Deep Dives</a> section covers protocol internals, Raft modifications, and design decisions.</li>
</ul>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>A minimal mosaik node that joins a network and starts streaming data:</p>
<pre><code class="language-rust ignore">use mosaik::*;
use futures::SinkExt;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let network_id: NetworkId = "my-app".into();
    let network = Network::new(network_id).await?;

    // The node is now online and discoverable
    println!("Node {} is online", network.local().id());

    // Create a typed producer (any serializable type works)
    let producer = network.streams().produce::&lt;String&gt;();

    // Wait for at least one consumer to connect
    producer.when().online().await;

    // Send data
    producer.send("hello, world".to_string()).await?;

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Mosaik is a Rust runtime for building self-organizing, leaderless distributed systems. It targets <strong>trusted, permissioned networks</strong> — environments where all participating nodes are controlled by the same organization and assumed to be honest.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Self-organizing</strong></td><td>Nodes discover each other via gossip and form the correct topology automatically</td></tr>
<tr><td><strong>Typed pub/sub</strong></td><td>Stream any serializable Rust type between nodes with backpressure and filtering</td></tr>
<tr><td><strong>Raft consensus</strong></td><td>Form availability groups with leader election and replicated state machines</td></tr>
<tr><td><strong>Replicated collections</strong></td><td>Distributed <code>Map</code>, <code>Vec</code>, <code>Set</code>, and <code>PriorityQueue</code> with strong consistency</td></tr>
<tr><td><strong>QUIC transport</strong></td><td>Built on <a href="https://github.com/n0-computer/iroh">iroh</a> for modern, encrypted P2P networking</td></tr>
<tr><td><strong>Relay support</strong></td><td>Nodes behind NAT can communicate via relay servers with automatic hole-punching</td></tr>
</tbody>
</table>
</div>
<h2 id="module-map"><a class="header" href="#module-map">Module Map</a></h2>
<p>Mosaik is organized into five composable subsystems:</p>
<pre><code class="language-text">┌──────────────────────────────────────────────────────┐
│                     Network                          │
│  Entry point. QUIC endpoint, identity, routing.      │
├─────────────┬─────────────┬─────────────┬────────────┤
│  Discovery  │   Streams   │   Groups    │Collections │
│  Gossip &amp;   │  Typed      │  Raft       │ Replicated │
│  peer       │  pub/sub    │  consensus  │ Map, Vec,  │
│  catalog    │  channels   │  groups     │ Set, DEPQ  │
└─────────────┴─────────────┴─────────────┴────────────┘
</code></pre>
<h3 id="network"><a class="header" href="#network">Network</a></h3>
<p>The entry point to the SDK. Creates the QUIC endpoint, manages node identity (derived from a secret key), and composes all subsystems via ALPN-based protocol multiplexing.</p>
<h3 id="discovery"><a class="header" href="#discovery">Discovery</a></h3>
<p>Gossip-based peer discovery. Maintains a <strong>catalog</strong> — a synchronized view of all known peers, their capabilities (tags), and their available streams and groups. Uses two complementary protocols: real-time gossip announcements and full catalog synchronization for catch-up.</p>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<p>Typed, async pub/sub data channels. Any Rust type implementing <code>Serialize + DeserializeOwned + Send + 'static</code> can be streamed. Producers publish data; consumers subscribe. Discovery automatically connects matching producers and consumers across the network.</p>
<h3 id="groups"><a class="header" href="#groups">Groups</a></h3>
<p>Availability groups coordinated by a modified Raft consensus protocol. Nodes sharing a group key form a cluster, elect a leader, and replicate commands through a shared log. Custom state machines define application logic that runs deterministically on all group members.</p>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<p>Higher-level replicated data structures built on Groups. Each collection (<code>Map</code>, <code>Vec</code>, <code>Set</code>, <code>PriorityQueue</code>) creates its own Raft group with a specialized state machine.</p>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<h3 id="trusted-network-assumption"><a class="header" href="#trusted-network-assumption">Trusted Network Assumption</a></h3>
<p>Mosaik is <strong>not</strong> Byzantine fault tolerant. All nodes are assumed to be honest and correctly implementing the protocol. This assumption enables:</p>
<ul>
<li>Simpler consensus (no need for 2/3 supermajority)</li>
<li>Higher throughput (fewer message rounds)</li>
<li>Simplified state sync (no fraud proofs needed)</li>
</ul>
<p>This makes mosaik ideal for infrastructure controlled by a single organization, such as L2 chains, internal microservices, or distributed compute clusters.</p>
<h3 id="built-on-iroh"><a class="header" href="#built-on-iroh">Built on iroh</a></h3>
<p>Mosaik uses <a href="https://github.com/n0-computer/iroh">iroh</a> for its networking layer, which provides:</p>
<ul>
<li><strong>QUIC transport</strong> — multiplexed, encrypted connections</li>
<li><strong>Relay servers</strong> — NAT traversal for nodes behind firewalls</li>
<li><strong>mDNS</strong> — optional local network discovery</li>
<li><strong>Endpoint identity</strong> — public keys as node identifiers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Rust ≥ 1.89</strong> (edition 2024)</li>
<li>A Unix-like OS (Linux, macOS) or Windows</li>
</ul>
<h2 id="add-to-your-project"><a class="header" href="#add-to-your-project">Add to Your Project</a></h2>
<p>Add mosaik to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
mosaik = "0.2"
</code></pre>
<p>Mosaik pulls in its core dependencies automatically, including:</p>
<ul>
<li><a href="https://docs.rs/tokio"><code>tokio</code></a> — async runtime (full features)</li>
<li><a href="https://docs.rs/iroh"><code>iroh</code></a> — QUIC-based P2P networking</li>
<li><a href="https://docs.rs/serde"><code>serde</code></a> — serialization framework</li>
<li><a href="https://docs.rs/futures"><code>futures</code></a> — <code>Stream</code> and <code>Sink</code> traits</li>
</ul>
<h2 id="common-additional-dependencies"><a class="header" href="#common-additional-dependencies">Common Additional Dependencies</a></h2>
<p>Most mosaik applications will also want:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
futures = "0.3"
anyhow = "1"
</code></pre>
<ul>
<li><strong><code>tokio</code></strong> — you need the tokio runtime to run mosaik</li>
<li><strong><code>serde</code> with <code>derive</code></strong> — for <code>#[derive(Serialize, Deserialize)]</code> on your data types</li>
<li><strong><code>futures</code></strong> — for <code>StreamExt</code> / <code>SinkExt</code> traits on consumers and producers</li>
</ul>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>Create a minimal test to verify everything links correctly:</p>
<pre><code class="language-rust ignore">use mosaik::{Network, NetworkId};

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let network = Network::new("test-network".into()).await?;
    println!("Node online: {}", network.local().id());
    Ok(())
}</code></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<p>If you see a node ID printed, mosaik is installed and working.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Mosaik currently does not define any optional feature flags. All functionality is included by default.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide walks through a complete example: two nodes that discover each other and exchange typed data through a stream.</p>
<h2 id="step-1-create-the-network"><a class="header" href="#step-1-create-the-network">Step 1: Create the Network</a></h2>
<p>Every mosaik application starts by creating a <code>Network</code>. The <code>NetworkId</code> ensures only nodes on the same logical network can communicate.</p>
<pre><code class="language-rust ignore">use mosaik::{Network, NetworkId};

let network_id: NetworkId = "my-app".into();
let network = Network::new(network_id).await?;</code></pre>
<p><code>Network::new()</code> creates a node with default settings:</p>
<ul>
<li>A random secret key (new identity each run — this is the recommended default)</li>
<li>Default relay mode (uses iroh’s relay servers for NAT traversal)</li>
<li>No bootstrap peers (fine for local testing)</li>
<li>No tags</li>
</ul>
<p>For production use, you’ll want <code>Network::builder()</code> to configure bootstrap peers so the node can find the network. A fixed secret key is only needed for bootstrap nodes that need a stable peer ID — regular nodes work fine with the auto-generated key. See the <a href="#network-1">Network</a> chapter.</p>
<h2 id="step-2-define-your-data-type"><a class="header" href="#step-2-define-your-data-type">Step 2: Define Your Data Type</a></h2>
<p>Streams in mosaik are typed. Any type implementing <code>Serialize + DeserializeOwned + Send + 'static</code> automatically implements the <code>Datum</code> trait and can be streamed:</p>
<pre><code class="language-rust ignore">use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct SensorReading {
    sensor_id: u64,
    temperature: f64,
    timestamp: u64,
}</code></pre>
<h2 id="step-3-create-a-producer"><a class="header" href="#step-3-create-a-producer">Step 3: Create a Producer</a></h2>
<p>A producer publishes data for consumers across the network. The stream ID is derived from the type name by default.</p>
<pre><code class="language-rust ignore">let producer = network.streams().produce::&lt;SensorReading&gt;();

// Wait until at least one consumer connects
producer.when().subscribed().await;</code></pre>
<h2 id="step-4-send-data"><a class="header" href="#step-4-send-data">Step 4: Send Data</a></h2>
<p><code>Producer</code> implements the <code>futures::Sink</code> trait. You can use <code>SinkExt::send()</code> for awaitable sends:</p>
<pre><code class="language-rust ignore">use futures::SinkExt;

producer.send(SensorReading {
    sensor_id: 1,
    temperature: 22.5,
    timestamp: 1700000000,
}).await?;</code></pre>
<p>For non-blocking sends, use <code>try_send()</code>:</p>
<pre><code class="language-rust ignore">producer.try_send(SensorReading {
    sensor_id: 1,
    temperature: 23.1,
    timestamp: 1700000001,
})?;</code></pre>
<h2 id="step-5-create-a-consumer-on-another-node"><a class="header" href="#step-5-create-a-consumer-on-another-node">Step 5: Create a Consumer (On Another Node)</a></h2>
<p>On a different node (or the same node for testing), create a consumer for the same type:</p>
<pre><code class="language-rust ignore">let other_network = Network::new(network_id).await?;

let mut consumer = other_network.streams().consume::&lt;SensorReading&gt;();

// Wait for subscription to a producer
consumer.when().subscribed().await;</code></pre>
<h2 id="step-6-receive-data"><a class="header" href="#step-6-receive-data">Step 6: Receive Data</a></h2>
<p><code>Consumer</code> implements <code>futures::Stream</code>. Use <code>StreamExt::next()</code> to receive:</p>
<pre><code class="language-rust ignore">use futures::StreamExt;

while let Some(reading) = consumer.next().await {
    println!("Sensor {}: {}°C", reading.sensor_id, reading.temperature);
}</code></pre>
<p>Or use the direct <code>recv()</code> method:</p>
<pre><code class="language-rust ignore">if let Some(reading) = consumer.recv().await {
    println!("Got reading: {:?}", reading);
}</code></pre>
<h2 id="step-7-discovery-connecting-the-nodes"><a class="header" href="#step-7-discovery-connecting-the-nodes">Step 7: Discovery (Connecting the Nodes)</a></h2>
<p>For nodes to find each other, they need at least one common peer address. In local testing, you can trigger manual discovery:</p>
<pre><code class="language-rust ignore">// On the consumer's network, dial the producer's address
other_network.discovery().sync_with(network.local().addr()).await?;</code></pre>
<p>In production, you’ll configure bootstrap peers:</p>
<pre><code class="language-rust ignore">use mosaik::discovery;

let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
    )
    .build()
    .await?;</code></pre>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Here’s the complete example as two async tasks simulating two nodes:</p>
<pre><code class="language-rust ignore">use futures::{SinkExt, StreamExt};
use mosaik::{Network, NetworkId};
use serde::{Deserialize, Serialize};
use std::pin::pin;

#[derive(Debug, Clone, Serialize, Deserialize)]
struct SensorReading {
    sensor_id: u64,
    temperature: f64,
}

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let network_id: NetworkId = "sensor-network".into();

    // Node 1: Producer
    let node1 = Network::new(network_id).await?;
    let producer = node1.streams().produce::&lt;SensorReading&gt;();

    // Node 2: Consumer
    let node2 = Network::new(network_id).await?;
    let mut consumer = node2.streams().consume::&lt;SensorReading&gt;();

    // Connect the nodes
    node2.discovery().dial(node1.local().addr()).await?;

    // Wait for the stream to be established
    producer.when().online().await;

    // Send data
    for i in 0..10 {
        producer.send(SensorReading {
            sensor_id: 1,
            temperature: 20.0 + i as f64 * 0.5,
        }).await?;
    }

    // Receive data
    for _ in 0..10 {
        let reading = consumer.recv().await.unwrap();
        println!("{:?}", reading);
    }

    Ok(())
}</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next</a></h2>
<ul>
<li><strong><a href="#building-a-bootstrap-node">Tutorials</a></strong> — Walk through the included examples</li>
<li><strong><a href="#streams-1">Streams</a></strong> — Producer/consumer configuration, filtering, backpressure</li>
<li><strong><a href="#groups-1">Groups</a></strong> — Raft consensus and replicated state machines</li>
<li><strong><a href="#collections-1">Collections</a></strong> — Distributed Map, Vec, Set, PriorityQueue</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This chapter describes how mosaik’s subsystems fit together, how protocols are multiplexed, and how the lifecycle of a node is managed.</p>
<h2 id="subsystem-composition"><a class="header" href="#subsystem-composition">Subsystem Composition</a></h2>
<p>A <code>Network</code> is the top-level entry point. When built, it creates and composes four subsystems:</p>
<pre><code class="language-text">Network::builder(network_id)
    │
    ├── LocalNode          (QUIC endpoint, identity, lifecycle)
    ├── Discovery          (gossip announcements, catalog sync)
    ├── Streams            (typed pub/sub channels)
    └── Groups             (Raft consensus groups)
            └── Collections  (replicated Map, Vec, Set, PriorityQueue)
</code></pre>
<p>Each subsystem is created during <code>Network::builder().build()</code> and installed as a protocol handler on the iroh <code>Router</code>. The subsystems are then accessible via accessor methods:</p>
<pre><code class="language-rust ignore">let network = Network::builder(network_id).build().await?;

let local     = network.local();       // LocalNode
let discovery = network.discovery();   // Discovery
let streams   = network.streams();     // Streams
let groups    = network.groups();      // Groups</code></pre>
<p>All handles are cheap to clone (they wrap <code>Arc</code> internally).</p>
<h2 id="alpn-based-protocol-multiplexing"><a class="header" href="#alpn-based-protocol-multiplexing">ALPN-Based Protocol Multiplexing</a></h2>
<p>Mosaik multiplexes multiple protocols over a single QUIC endpoint using <strong>ALPN</strong> (Application-Layer Protocol Negotiation). Each subsystem registers its own ALPN identifier:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Subsystem</th><th>ALPN</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>Discovery (announce)</td><td><code>/mosaik/announce</code></td><td>Real-time gossip broadcasts</td></tr>
<tr><td>Discovery (sync)</td><td><code>/mosaik/catalog-sync</code></td><td>Full catalog exchange</td></tr>
<tr><td>Streams</td><td><code>/mosaik/streams/1.0</code></td><td>Pub/sub data channels</td></tr>
<tr><td>Groups</td><td><code>/mosaik/groups/1</code></td><td>Raft consensus, bonds, state sync</td></tr>
</tbody>
</table>
</div>
<p>When a connection arrives, the iroh router inspects the ALPN and dispatches to the correct subsystem handler. This means all subsystems share the same QUIC endpoint and port.</p>
<p>Subsystems implement the <code>ProtocolProvider</code> trait to install their handlers:</p>
<pre><code class="language-rust ignore">// Internal trait — subsystems implement this
trait ProtocolProvider {
    fn install(self, router: &amp;mut Router);
}</code></pre>
<p>The <code>Protocol</code> trait defines the ALPN for typed links:</p>
<pre><code class="language-rust ignore">pub trait Protocol {
    const ALPN: &amp;'static [u8];
}</code></pre>
<h2 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h2>
<p><code>Network</code> uses a builder pattern for configuration:</p>
<pre><code class="language-rust ignore">let network = Network::builder(network_id)
    .with_secret_key(secret_key)           // Stable identity
    .with_relay_mode(RelayMode::Disabled)  // No relay servers
    .with_mdns_discovery(true)             // Local network discovery
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
            .with_tags("my-role")
    )
    .with_streams(
        streams::Config::builder()
            .with_backoff(ExponentialBackoff::default())
    )
    .with_groups(
        groups::Config::builder()
    )
    .build()
    .await?;</code></pre>
<p>For quick prototyping, <code>Network::new(network_id)</code> uses all defaults.</p>
<h2 id="lifecycle--shutdown"><a class="header" href="#lifecycle--shutdown">Lifecycle &amp; Shutdown</a></h2>
<p>Mosaik uses <code>tokio_util::sync::CancellationToken</code> for structured lifecycle management. The token lives in <code>LocalNode</code> and propagates shutdown to all subsystems:</p>
<pre><code class="language-text">Network::drop()
    │
    ├── cancels LocalNode's CancellationToken
    │       │
    │       ├── Discovery workers shut down
    │       ├── Stream producer/consumer workers shut down
    │       ├── Group bond workers + Raft shut down
    │       └── iroh Router shuts down
    │
    └── all resources released
</code></pre>
<p>When a <code>Network</code> is dropped, the cancellation token is triggered, and all background tasks gracefully terminate. Each subsystem’s internal tasks are select-looped against the cancellation token, ensuring no orphaned tasks.</p>
<h2 id="internal-communication-patterns"><a class="header" href="#internal-communication-patterns">Internal Communication Patterns</a></h2>
<p>Mosaik uses several recurring patterns internally:</p>
<h3 id="watch-channels"><a class="header" href="#watch-channels">Watch Channels</a></h3>
<p>Status changes are broadcast via <code>tokio::sync::watch</code> channels. This enables the <code>when()</code> API:</p>
<pre><code class="language-rust ignore">// Wait for a stream producer to come online
producer.when().online().await;

// Wait for a Raft group leader to be elected
group.when().leader_elected().await;

// Wait for a collection to reach a specific version
collection.when().reaches(version).await;</code></pre>
<h3 id="arcinner-pattern"><a class="header" href="#arcinner-pattern">Arc&lt;Inner&gt; Pattern</a></h3>
<p>All public handles (<code>Network</code>, <code>Discovery</code>, <code>Streams</code>, <code>Groups</code>, <code>Group</code>, <code>Producer</code>, <code>Consumer</code>, <code>Map</code>, <code>Vec</code>, etc.) are cheap to clone. They wrap an <code>Arc&lt;Inner&gt;</code> containing the actual state, making them safe to share across tasks.</p>
<h3 id="task-per-connection"><a class="header" href="#task-per-connection">Task-Per-Connection</a></h3>
<p>Each consumer subscription and each producer-subscriber pair runs in its own tokio task. This avoids head-of-line blocking — a slow consumer doesn’t affect other consumers, and a slow subscriber doesn’t block the producer.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="identity--networking"><a class="header" href="#identity--networking">Identity &amp; Networking</a></h1>
<p>Mosaik’s identity system is built on cryptographic keys and content-addressed hashing. Every identifier in the system — networks, peers, streams, groups, collections — is a 32-byte <code>Digest</code> (blake3 hash).</p>
<h2 id="uniqueid-the-universal-identifier"><a class="header" href="#uniqueid-the-universal-identifier">UniqueId: The Universal Identifier</a></h2>
<p>At the core of mosaik’s identity system is <code>Digest</code> — a 32-byte blake3 hash that serves as the universal identifier type:</p>
<pre><code class="language-rust ignore">use mosaik::Digest;

// From a string (hashes the string if not valid hex)
let id: UniqueId = "my-network".into();

// From raw bytes
let id = UniqueId::from_bytes([0u8; 32]);

// Random
let id = UniqueId::random();

// Compile-time constants via the unique_id! macro
use mosaik::unique_id;

// From a 64-char hex string (decoded directly):
const HEX_ID: UniqueId = unique_id!(
    "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
);

// From any arbitrary string (blake3-hashed at compile time):
const NAMED_ID: UniqueId = unique_id!("my-stream-name");

// Deterministic derivation
let derived = id.derive("sub-identifier");</code></pre>
<p>All the following types are aliases for <code>Digest</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Alias For</th><th>Identifies</th></tr>
</thead>
<tbody>
<tr><td><code>UniqueId</code></td><td><code>Digest</code></td><td>General-purpose unique identifier</td></tr>
<tr><td><code>NetworkId</code></td><td><code>UniqueId</code></td><td>A mosaik network (derived from name)</td></tr>
<tr><td><code>Tag</code></td><td><code>UniqueId</code></td><td>A capability or role label</td></tr>
<tr><td><code>StreamId</code></td><td><code>UniqueId</code></td><td>A data stream (derived from type name)</td></tr>
<tr><td><code>GroupId</code></td><td><code>UniqueId</code></td><td>A consensus group (derived from key + config)</td></tr>
<tr><td><code>StoreId</code></td><td><code>UniqueId</code></td><td>A replicated collection instance</td></tr>
</tbody>
</table>
</div>
<h2 id="peerid-node-identity"><a class="header" href="#peerid-node-identity">PeerId: Node Identity</a></h2>
<p>A <code>PeerId</code> is the node’s public key, derived from its secret key. It’s globally unique across all mosaik networks.</p>
<pre><code class="language-rust ignore">use mosaik::{Network, PeerId};
use iroh::SecretKey;

// Random identity (default when using Network::new)
let network = Network::new(network_id).await?;
let my_id: &amp;PeerId = &amp;network.local().id();

// Stable identity via explicit secret key
let secret = SecretKey::generate(&amp;mut rand::rng());
let network = Network::builder(network_id)
    .with_secret_key(secret)
    .build()
    .await?;</code></pre>
<p>For bootstrap nodes and other long-lived infrastructure, you should use a fixed secret key so the node’s <code>PeerId</code> (and therefore its address) remains stable across restarts.</p>
<h2 id="networkid-network-isolation"><a class="header" href="#networkid-network-isolation">NetworkId: Network Isolation</a></h2>
<p>A <code>NetworkId</code> is a <code>Digest</code> derived from a name string. Nodes can only connect to peers sharing the same <code>NetworkId</code>:</p>
<pre><code class="language-rust ignore">use mosaik::NetworkId;

// These produce the same NetworkId
let id1: NetworkId = "my-app".into();
let id2: NetworkId = "my-app".into();
assert_eq!(id1, id2);

// Different name → different network → can't communicate
let other: NetworkId = "other-app".into();
assert_ne!(id1, other);</code></pre>
<p>The <code>NetworkId</code> also drives <strong>automatic peer discovery</strong>: nodes sharing the same <code>NetworkId</code> find each other through the <a href="#dht-bootstrap">Mainline DHT</a> without requiring any hardcoded bootstrap peers. Simply using the same network name is enough for nodes to connect.</p>
<h2 id="tags-capability-labels"><a class="header" href="#tags-capability-labels">Tags: Capability Labels</a></h2>
<p>Tags are <code>Digest</code> values used to describe a node’s role or capabilities:</p>
<pre><code class="language-rust ignore">use mosaik::Tag;

let tag: Tag = "matcher".into();
let another: Tag = "validator".into();</code></pre>
<p>Tags are advertised through the discovery system and can be used to filter which peers a producer accepts or which producers a consumer subscribes to:</p>
<pre><code class="language-rust ignore">// Only accept consumers that have the "authorized" tag
let producer = network.streams().producer::&lt;Order&gt;()
    .accept_if(|peer| peer.tags.contains(&amp;"authorized".into()))
    .build()?;</code></pre>
<h2 id="streamid-stream-identity"><a class="header" href="#streamid-stream-identity">StreamId: Stream Identity</a></h2>
<p>By default, a <code>StreamId</code> is derived from the Rust type name:</p>
<pre><code class="language-rust ignore">use mosaik::StreamId;

// Automatically derived from the type name
let producer = network.streams().produce::&lt;SensorReading&gt;();

// Or set explicitly
let producer = network.streams().producer::&lt;SensorReading&gt;()
    .with_stream_id("custom-stream-name")
    .build()?;</code></pre>
<h2 id="groupid-group-identity"><a class="header" href="#groupid-group-identity">GroupId: Group Identity</a></h2>
<p>A <code>GroupId</code> is deterministically derived from multiple inputs:</p>
<pre><code class="language-text">GroupId = hash(
    GroupKey,
    ConsensusConfig,
    StateMachine::signature(),
    StateSync::signature()
)
</code></pre>
<p>This ensures that nodes with different configurations, different state machines, or different group secrets <strong>cannot</strong> accidentally join the same group.</p>
<h2 id="endpoint-addresses"><a class="header" href="#endpoint-addresses">Endpoint Addresses</a></h2>
<p>Nodes are addressed using <code>EndpointAddr</code> from iroh, which encodes the public key and optional relay URL. This is what you pass to bootstrap peers:</p>
<pre><code class="language-rust ignore">let addr = network.local().addr();
// addr contains: PeerId + relay URL + direct addresses</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="self-organization"><a class="header" href="#self-organization">Self-Organization</a></h1>
<p>One of mosaik’s defining features is that nodes <strong>self-organize</strong> into the correct topology without manual configuration. This chapter explains how that works step by step.</p>
<h2 id="the-self-organization-loop"><a class="header" href="#the-self-organization-loop">The Self-Organization Loop</a></h2>
<p>When a new node joins the network, the following sequence happens automatically:</p>
<pre><code class="language-text">1. Bootstrap       Node connects to a known bootstrap peer
                       │
2. Gossip          Announce protocol broadcasts presence
                       │
3. Catalog Sync    Full catalog exchange with bootstrap peer
                       │
4. Discovery       Node learns about all other peers, their
                   tags, streams, and groups
                       │
5. Streams         Consumer discovers matching producers,
                   opens subscriptions automatically
                       │
6. Groups          Node finds peers with matching group keys,
                   forms bonds, joins Raft cluster
                       │
7. Convergence     Network reaches a stable topology where
                   all nodes are connected to the right peers
</code></pre>
<h2 id="step-1-bootstrap--gossip"><a class="header" href="#step-1-bootstrap--gossip">Step 1: Bootstrap &amp; Gossip</a></h2>
<p>A new node starts with at least one bootstrap peer address. It connects and begins participating in the gossip protocol:</p>
<pre><code class="language-rust ignore">let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
            .with_tags("matcher")
    )
    .build()
    .await?;</code></pre>
<p>The node immediately:</p>
<ul>
<li><strong>Announces</strong> itself via the gossip protocol (<code>/mosaik/announce</code>), broadcasting its <code>PeerEntry</code> (identity, tags, streams, groups)</li>
<li><strong>Receives</strong> announcements from other peers</li>
<li><strong>Triggers</strong> a full catalog sync (<code>/mosaik/catalog-sync</code>) with the bootstrap peer to catch up on all known peers</li>
</ul>
<h2 id="step-2-catalog-convergence"><a class="header" href="#step-2-catalog-convergence">Step 2: Catalog Convergence</a></h2>
<p>The catalog converges through two complementary protocols:</p>
<h3 id="real-time-gossip-announcements"><a class="header" href="#real-time-gossip-announcements">Real-time: Gossip Announcements</a></h3>
<p>Every node periodically re-announces its <code>PeerEntry</code> via iroh-gossip. The announce interval is configurable (default: 15 seconds) with jitter to avoid thundering herds:</p>
<pre><code class="language-text">announce_interval = 15s
announce_jitter = 0.5  →  actual interval: 7.5s – 22.5s
</code></pre>
<p>When a node changes (adds a tag, creates a stream, joins a group), it re-announces immediately.</p>
<h3 id="catch-up-full-catalog-sync"><a class="header" href="#catch-up-full-catalog-sync">Catch-up: Full Catalog Sync</a></h3>
<p>When a new node connects, it performs a bidirectional catalog sync with its peer. Both nodes exchange their complete catalogs, and entries are merged:</p>
<pre><code class="language-text">Node A                          Node B
  │                               │
  │── CatalogSyncRequest ───────► │
  │                               │
  │◄── CatalogSyncResponse ──────│
  │                               │
  │  (both merge received         │
  │   entries into local catalog) │
</code></pre>
<h3 id="signed-entries"><a class="header" href="#signed-entries">Signed Entries</a></h3>
<p>Each <code>PeerEntry</code> is cryptographically signed by its owner. This proves authenticity — you can trust that a peer entry’s tags, streams, and groups are genuine, even when received via gossip through intermediaries.</p>
<h3 id="staleness--purging"><a class="header" href="#staleness--purging">Staleness &amp; Purging</a></h3>
<p>Entries that haven’t been updated within the <code>purge_after</code> duration (default: 300 seconds) are considered stale and hidden from the public catalog API. This ensures departed nodes are eventually removed.</p>
<h2 id="step-3-automatic-stream-connections"><a class="header" href="#step-3-automatic-stream-connections">Step 3: Automatic Stream Connections</a></h2>
<p>Once discovery populates the catalog, the Streams subsystem automatically connects producers and consumers:</p>
<pre><code class="language-text">1. Node A creates Producer&lt;Order&gt;
   → Discovery advertises: "I produce stream 'Order'"

2. Node B creates Consumer&lt;Order&gt;
   → Discovery observes: "Node A produces 'Order'"
   → Consumer worker opens subscription to Node A

3. Data flows: Node A ──[Order]──► Node B
</code></pre>
<p>This is fully automatic. The consumer’s background worker monitors the catalog for matching producers and establishes connections as they appear.</p>
<p>Filtering can restrict which connections form:</p>
<pre><code class="language-rust ignore">// Producer only accepts nodes tagged "authorized"
let producer = network.streams().producer::&lt;Order&gt;()
    .accept_if(|peer| peer.tags.contains(&amp;"authorized".into()))
    .build()?;

// Consumer only subscribes to nodes tagged "primary"
let consumer = network.streams().consumer::&lt;Order&gt;()
    .subscribe_if(|peer| peer.tags.contains(&amp;"primary".into()))
    .build();</code></pre>
<h2 id="step-4-automatic-group-formation"><a class="header" href="#step-4-automatic-group-formation">Step 4: Automatic Group Formation</a></h2>
<p>Groups form through a similar discovery-driven process:</p>
<pre><code class="language-text">1. Node A joins group with key K
   → Discovery advertises: "I'm in group G" (where G = hash(K, config, ...))

2. Node B joins group with same key K
   → Discovery observes: "Node A is in group G"
   → Bond worker opens connection to Node A

3. Mutual handshake proves both know key K
   → Bond established

4. Raft consensus begins
   → Leader elected among bonded peers
   → Commands can be replicated
</code></pre>
<p>The bond handshake uses HMAC over the TLS session secrets combined with the group key. This proves knowledge of the group secret without transmitting it.</p>
<h2 id="step-5-late-joiners"><a class="header" href="#step-5-late-joiners">Step 5: Late Joiners</a></h2>
<p>A node joining an already-running network catches up automatically:</p>
<h3 id="stream-catch-up"><a class="header" href="#stream-catch-up">Stream Catch-up</a></h3>
<p>Consumers connecting to an active producer receive data from the point of subscription. There’s no historical replay — streams are real-time.</p>
<h3 id="group-catch-up"><a class="header" href="#group-catch-up">Group Catch-up</a></h3>
<p>A node joining an existing Raft group:</p>
<ol>
<li>Forms bonds with existing members</li>
<li>Receives the current log from peers (distributed across multiple peers for efficiency)</li>
<li>Applies all log entries to bring its state machine up to date</li>
<li>Begins participating normally (can vote, can become leader)</li>
</ol>
<p>For collections, catch-up can use either log replay or snapshot sync:</p>
<ul>
<li><strong>Log replay</strong> (default): Replays the entire log from the beginning</li>
<li><strong>Snapshot sync</strong>: Transfers a point-in-time snapshot of the state, avoiding log replay for large states</li>
</ul>
<h2 id="topology-example"><a class="header" href="#topology-example">Topology Example</a></h2>
<p>Consider a distributed trading system with three roles:</p>
<pre><code class="language-text">Tags: "trader"          Tags: "matcher"         Tags: "reporter"
┌──────────┐            ┌──────────┐            ┌──────────┐
│  Node 1  │            │  Node 3  │            │  Node 5  │
│ Producer │──[Order]──►│ Consumer │            │ Consumer │
│ &lt;Order&gt;  │            │ &lt;Order&gt;  │            │  &lt;Fill&gt;  │
└──────────┘            │          │            └──────────┘
                        │ Group:   │──[Fill]──►      ▲
┌──────────┐            │ OrderBook│            ┌──────────┐
│  Node 2  │            │ (Raft)   │            │  Node 6  │
│ Producer │──[Order]──►│          │            │ Consumer │
│ &lt;Order&gt;  │            │ Producer │──[Fill]──►│  &lt;Fill&gt;  │
└──────────┘            │  &lt;Fill&gt;  │            └──────────┘
                        └──────────┘
                        ┌──────────┐
                        │  Node 4  │
                        │ (matcher │
                        │  replica)│
                        └──────────┘
</code></pre>
<p>All of this topology forms <strong>automatically</strong> from:</p>
<ul>
<li>Node 1–2: <code>with_tags("trader")</code>, creates <code>Producer&lt;Order&gt;</code></li>
<li>Node 3–4: <code>with_tags("matcher")</code>, creates <code>Consumer&lt;Order&gt;</code>, joins orderbook group, creates <code>Producer&lt;Fill&gt;</code></li>
<li>Node 5–6: <code>with_tags("reporter")</code>, creates <code>Consumer&lt;Fill&gt;</code></li>
</ul>
<p>No node needs to know the addresses of any other node except one bootstrap peer.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-a-bootstrap-node"><a class="header" href="#building-a-bootstrap-node">Building a Bootstrap Node</a></h1>
<p>This tutorial walks through the <a href="https://github.com/flashbots/mosaik/blob/main/examples/bootstrap.rs">bootstrap example</a> — a ready-to-use bootstrap node for any mosaik network.</p>
<h2 id="what-is-a-bootstrap-node"><a class="header" href="#what-is-a-bootstrap-node">What Is a Bootstrap Node?</a></h2>
<p>A bootstrap node is the first peer that other nodes connect to when joining a network. It serves as the initial discovery point — once a new node connects to a bootstrap peer, the gossip protocol takes over and the joining node learns about all other peers.</p>
<p>Bootstrap nodes are typically:</p>
<ul>
<li><strong>Long-lived</strong> — they run continuously</li>
<li><strong>Stable identity</strong> — they use a fixed secret key so their address doesn’t change across restarts</li>
<li><strong>Well-known</strong> — their address is configured as a bootstrap peer by other nodes</li>
</ul>
<p>A bootstrap node doesn’t need any special code — it’s just a regular mosaik node that stays online. The <a href="https://github.com/flashbots/mosaik/blob/main/examples/bootstrap.rs">bootstrap example</a> can be used in production as a <strong>universal bootstrap node</strong> for any mosaik network. The example adds CLI configuration with <code>clap</code>.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The bootstrap example is a single file at <code>examples/bootstrap.rs</code>. It uses these dependencies:</p>
<pre><code class="language-toml">[dependencies]
mosaik = "0.2"
tokio = { version = "1", features = ["full"] }
clap = { version = "4", features = ["derive"] }
tracing = "0.1"
tracing-subscriber = "0.3"
anyhow = "1"
</code></pre>
<h2 id="the-cli-interface"><a class="header" href="#the-cli-interface">The CLI Interface</a></h2>
<p>The example uses <code>clap</code> derive to define command-line options:</p>
<pre><code class="language-rust ignore">use clap::{ArgAction, Parser};
use mosaik::*;

#[derive(Debug, Parser)]
struct Opts {
    /// The secret key for stable identity across restarts
    #[clap(short, long, env = "MOSAIK_BOOTSTRAP_SECRET")]
    secret: Option&lt;SecretKey&gt;,

    /// The network ID (hex string or seed that gets hashed)
    #[clap(short, long, env = "MOSAIK_BOOTSTRAP_NETWORK_ID")]
    network_id: Option&lt;NetworkId&gt;,

    /// Other bootstrap nodes to connect to on startup
    #[clap(short, long, env = "MOSAIK_BOOTSTRAP_PEERS")]
    peers: Vec&lt;PeerId&gt;,

    /// Tags to advertise (default: "bootstrap")
    #[clap(short, long, default_value = "bootstrap",
           env = "MOSAIK_BOOTSTRAP_TAGS")]
    tags: Vec&lt;Tag&gt;,

    /// Disable relay servers (node must be directly reachable)
    #[clap(long, default_value_t = false)]
    no_relay: bool,

    /// Verbose output (-v debug, -vv trace)
    #[clap(short, action = ArgAction::Count)]
    verbose: u8,

    /// Suppress all output
    #[clap(short, long)]
    quiet: bool,
}</code></pre>
<p>Every option also supports environment variables (<code>MOSAIK_BOOTSTRAP_*</code>), making it easy to configure in containers or systemd services.</p>
<h2 id="secret-key-handling"><a class="header" href="#secret-key-handling">Secret Key Handling</a></h2>
<p>The secret key determines the node’s <code>PeerId</code>. For a bootstrap node, a stable identity is essential so that other nodes can reliably find it:</p>
<pre><code class="language-rust ignore">fn parse_secret_key(s: &amp;str) -&gt; Result&lt;SecretKey, Infallible&gt; {
    let bytes = Digest::from(s);
    Ok(SecretKey::from_bytes(bytes.as_bytes()))
}</code></pre>
<p>This parser accepts two formats:</p>
<ul>
<li><strong>64-character hex string</strong> — used directly as the secret key bytes</li>
<li><strong>Any other string</strong> — treated as a seed, hashed with blake3 into a deterministic key</li>
</ul>
<p>So <code>--secret=my-bootstrap-1</code> always produces the same key, making deployment reproducible.</p>
<h2 id="building-the-network"><a class="header" href="#building-the-network">Building the Network</a></h2>
<p>The <code>main</code> function assembles the <code>Network</code> using the builder:</p>
<pre><code class="language-rust ignore">#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let opts = Opts::parse();

    let secret = opts.secret.unwrap_or_else(|| {
        tracing::warn!("No secret key provided, generating random key");
        SecretKey::generate(&amp;mut rand::rng())
    });

    let network_id = opts.network_id.unwrap_or_else(|| {
        tracing::warn!("No network id provided, generating random network id");
        NetworkId::random()
    });

    let mut builder = Network::builder(network_id)
        .with_secret_key(secret)
        .with_discovery(
            discovery::Config::builder()
                .with_tags(opts.tags.clone())
                .with_bootstrap(opts.peers.clone()),
        );

    if opts.no_relay {
        builder = builder.with_relay_mode(iroh::RelayMode::Disabled);
    }

    let network = builder.build().await?;

    tracing::info!("Bootstrap node started");
    tracing::info!("Public Id: {}", network.local().id());
    tracing::info!("Network Id: {:?}", network.network_id());

    // Stay alive forever
    core::future::pending::&lt;()&gt;().await;
    Ok(())
}</code></pre>
<p>Key points:</p>
<ol>
<li><strong><code>with_secret_key()</code></strong> — sets the stable identity</li>
<li><strong><code>with_discovery()</code></strong> — configures tags and initial peers to dial</li>
<li><strong><code>with_relay_mode(Disabled)</code></strong> — optional, for nodes with direct connectivity</li>
<li><strong><code>core::future::pending()</code></strong> — keeps the process alive (the node runs in background tasks)</li>
</ol>
<h2 id="running-it"><a class="header" href="#running-it">Running It</a></h2>
<pre><code class="language-bash"># Basic usage with a seed-based secret
cargo run --example bootstrap -- \
    --network-id=my-network \
    --secret=my-bootstrap-secret

# With environment variables
MOSAIK_BOOTSTRAP_SECRET=my-secret \
MOSAIK_BOOTSTRAP_NETWORK_ID=my-network \
cargo run --example bootstrap

# Multiple bootstrap nodes that know each other
cargo run --example bootstrap -- \
    --network-id=my-network \
    --secret=node-1 \
    --peers=&lt;peer-id-of-node-2&gt;
</code></pre>
<h2 id="using-the-bootstrap-node"><a class="header" href="#using-the-bootstrap-node">Using the Bootstrap Node</a></h2>
<p>Other nodes reference the bootstrap node’s address when joining the network:</p>
<pre><code class="language-rust ignore">let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
    )
    .build()
    .await?;</code></pre>
<p>The joining node connects to the bootstrap peer, performs a full catalog sync, and then discovers all other nodes through gossip. From that point on, the joining node is a full participant — it doesn’t need the bootstrap node for ongoing operation.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li><strong>Bootstrap nodes are just regular nodes</strong> — no special server code needed</li>
<li><strong>Stable identity via secret key</strong> — ensures the address doesn’t change across restarts</li>
<li><strong>Tags for discoverability</strong> — the <code>"bootstrap"</code> tag lets other nodes identify bootstrap peers</li>
<li><strong>Minimal configuration</strong> — a secret key and network ID are all that’s required</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-a-distributed-orderbook"><a class="header" href="#building-a-distributed-orderbook">Building a Distributed Orderbook</a></h1>
<p>This tutorial walks through the <a href="https://github.com/flashbots/mosaik/tree/main/examples/orderbook">orderbook example</a> — a distributed order-matching engine that combines Streams, Groups, and Raft consensus.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The orderbook example demonstrates how multiple mosaik subsystems compose to build a realistic distributed system:</p>
<pre><code class="language-text">         Traders                  Matchers                 Observers
    ┌────────────┐          ┌──────────────────┐      ┌────────────┐
    │  Trader A  │          │    Matcher 0     │      │  Observer  │
    │  Producer  │─[Order]─►│    Consumer      │      │  Consumer  │
    │  &lt;Order&gt;   │          │    &lt;Order&gt;       │      │  &lt;Fill&gt;    │
    └────────────┘          │                  │      └────────────┘
                            │  ┌────────────┐  │           ▲
    ┌────────────┐          │  │  OrderBook │  │           │
    │  Trader B  │          │  │  (Raft SM) │  │──[Fill]───┘
    │  Producer  │─[Order]─►│  │            │  │
    │  &lt;Order&gt;   │          │  └────────────┘  │
    └────────────┘          │    Producer      │
                            │    &lt;Fill&gt;        │
                            └──────────────────┘
                            ┌──────────────────┐
                            │    Matcher 1     │
                            │    (replica)     │
                            └──────────────────┘
                            ┌──────────────────┐
                            │    Matcher 2     │
                            │    (replica)     │
                            └──────────────────┘
</code></pre>
<ol>
<li><strong>Traders</strong> produce <code>Order</code> objects via Streams</li>
<li><strong>Matchers</strong> (a 3-node Raft group) consume orders, replicate them through consensus, and run a price-time priority matching engine</li>
<li>Fill events are published back as a stream for downstream consumers</li>
</ol>
<h2 id="step-1-define-the-domain-types"><a class="header" href="#step-1-define-the-domain-types">Step 1: Define the Domain Types</a></h2>
<p>First, define the types that flow through the system. These types auto-implement the <code>Datum</code> trait for streaming:</p>
<pre><code class="language-rust ignore">use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TradingPair {
    pub base: String,
    pub quote: String,
}

impl TradingPair {
    pub fn new(base: &amp;str, quote: &amp;str) -&gt; Self {
        Self { base: base.to_string(), quote: quote.to_string() }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side { Bid, Ask }

/// Price in basis points (1 unit = 0.01). e.g., 300_000 = $3000.00
pub type Price = u64;
pub type Quantity = u64;

/// A limit order — streamable via mosaik Streams
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: u64,
    pub pair: TradingPair,
    pub side: Side,
    pub price: Price,
    pub quantity: Quantity,
    pub trader: String,
}

/// A fill produced when orders match
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fill {
    pub bid_order_id: u64,
    pub ask_order_id: u64,
    pub pair: TradingPair,
    pub price: Price,
    pub quantity: Quantity,
}</code></pre>
<p>Because <code>Order</code> and <code>Fill</code> derive <code>Serialize + Deserialize</code>, they automatically implement <code>Datum</code> and can be used with mosaik Streams.</p>
<h2 id="step-2-implement-the-state-machine"><a class="header" href="#step-2-implement-the-state-machine">Step 2: Implement the State Machine</a></h2>
<p>The heart of the example is the <code>OrderBook</code> state machine. It implements the <code>StateMachine</code> trait so it can be replicated across all group members via Raft:</p>
<pre><code class="language-rust ignore">use mosaik::groups::{ApplyContext, LogReplaySync, StateMachine};
use mosaik::primitives::UniqueId;
use std::collections::BTreeMap;

/// Commands that mutate the orderbook
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderBookCommand {
    PlaceOrder(Order),
    CancelOrder(u64),
}

/// Read-only queries against the orderbook state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderBookQuery {
    TopOfBook { pair: TradingPair, depth: usize },
    Fills,
    OrderCount,
}

/// Query results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderBookQueryResult {
    TopOfBook { bids: Vec&lt;(Price, Quantity)&gt;, asks: Vec&lt;(Price, Quantity)&gt; },
    Fills(Vec&lt;Fill&gt;),
    OrderCount(usize),
}</code></pre>
<p>The <code>StateMachine</code> trait requires four associated types:</p>
<ul>
<li><strong><code>Command</code></strong> — mutations that get replicated through Raft (must be serializable)</li>
<li><strong><code>Query</code></strong> — read requests (not replicated)</li>
<li><strong><code>QueryResult</code></strong> — responses to queries</li>
<li><strong><code>StateSync</code></strong> — mechanism for catching up new nodes</li>
</ul>
<p>And three core methods:</p>
<pre><code class="language-rust ignore">impl StateMachine for OrderBook {
    type Command = OrderBookCommand;
    type Query = OrderBookQuery;
    type QueryResult = OrderBookQueryResult;
    type StateSync = LogReplaySync&lt;Self&gt;;

    fn signature(&amp;self) -&gt; UniqueId {
        // Unique identifier for this state machine type.
        // Contributes to GroupId derivation — different state machines
        // produce different GroupIds even with the same key.
        UniqueId::from("orderbook_state_machine")
    }

    fn apply(&amp;mut self, command: Self::Command, _ctx: &amp;dyn ApplyContext) {
        match command {
            OrderBookCommand::PlaceOrder(order) =&gt; self.place_order(order),
            OrderBookCommand::CancelOrder(id) =&gt; self.cancel_order(id),
        }
    }

    fn query(&amp;self, query: Self::Query) -&gt; Self::QueryResult {
        match query {
            OrderBookQuery::TopOfBook { pair: _, depth } =&gt; {
                // Return top N price levels
                // ...
            }
            OrderBookQuery::Fills =&gt; {
                OrderBookQueryResult::Fills(self.fills.clone())
            }
            OrderBookQuery::OrderCount =&gt; {
                let count = self.bids.values()
                    .chain(self.asks.values())
                    .map(Vec::len).sum();
                OrderBookQueryResult::OrderCount(count)
            }
        }
    }

    fn state_sync(&amp;self) -&gt; Self::StateSync {
        LogReplaySync::default()
    }
}</code></pre>
<p>Key points:</p>
<ul>
<li><strong><code>apply()</code></strong> is called on every node in the same order — this is what Raft guarantees. The matching logic must be deterministic.</li>
<li><strong><code>query()</code></strong> reads local state without going through Raft. With <code>Consistency::Strong</code>, the query is forwarded to the leader.</li>
<li><strong><code>LogReplaySync::default()</code></strong> means new nodes catch up by replaying the entire command log from the beginning.</li>
</ul>
<h2 id="step-3-the-matching-engine"><a class="header" href="#step-3-the-matching-engine">Step 3: The Matching Engine</a></h2>
<p>The <code>OrderBook</code> implements price-time priority matching. When a new order arrives, it crosses against the opposite side:</p>
<pre><code class="language-rust ignore">impl OrderBook {
    fn match_order(&amp;mut self, order: &amp;Order) -&gt; Quantity {
        let mut remaining = order.quantity;

        match order.side {
            Side::Bid =&gt; {
                // Bids match against asks at or below the bid price
                while remaining &gt; 0 {
                    let Some((&amp;ask_price, _)) = self.asks.first_key_value()
                        else { break };
                    if ask_price &gt; order.price { break; }

                    let ask_level = self.asks.get_mut(&amp;ask_price).unwrap();
                    while remaining &gt; 0 &amp;&amp; !ask_level.is_empty() {
                        let (ask_id, ask_qty, _) = &amp;mut ask_level[0];
                        let fill_qty = remaining.min(*ask_qty);

                        self.fills.push(Fill {
                            bid_order_id: order.id,
                            ask_order_id: *ask_id,
                            pair: self.pair.clone(),
                            price: ask_price,
                            quantity: fill_qty,
                        });

                        remaining -= fill_qty;
                        *ask_qty -= fill_qty;
                        if *ask_qty == 0 { ask_level.remove(0); }
                    }
                    if ask_level.is_empty() {
                        self.asks.remove(&amp;ask_price);
                    }
                }
            }
            Side::Ask =&gt; {
                // Asks match against bids at or above the ask price
                // (mirror logic, iterating bids from highest)
                // ...
            }
        }
        remaining
    }

    fn place_order(&amp;mut self, order: Order) {
        let remaining = self.match_order(&amp;order);
        // Any unfilled quantity rests on the book
        if remaining &gt; 0 {
            let book = match order.side {
                Side::Bid =&gt; &amp;mut self.bids,
                Side::Ask =&gt; &amp;mut self.asks,
            };
            book.entry(order.price)
                .or_default()
                .push((order.id, remaining, order.trader));
        }
    }
}</code></pre>
<p>Because <code>apply()</code> is called in the same order on every replica (guaranteed by Raft), the matching results are identical across all nodes.</p>
<h2 id="step-4-wire-it-all-together"><a class="header" href="#step-4-wire-it-all-together">Step 4: Wire It All Together</a></h2>
<p>The <code>main</code> function creates the network, forms the Raft group, and connects streams:</p>
<pre><code class="language-rust ignore">#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let network_id = NetworkId::random();
    let group_key = GroupKey::random();
    let pair = TradingPair::new("ETH", "USDC");

    // --- 3 matcher nodes forming a Raft group ---
    let matcher0 = Network::new(network_id).await?;
    let matcher1 = Network::new(network_id).await?;
    let matcher2 = Network::new(network_id).await?;

    // Cross-discover all matchers
    discover_all([&amp;matcher0, &amp;matcher1, &amp;matcher2]).await?;

    // Each joins the same group with an OrderBook state machine
    let g0 = matcher0.groups().with_key(group_key)
        .with_state_machine(OrderBook::new(pair.clone()))
        .join();
    let g1 = matcher1.groups().with_key(group_key)
        .with_state_machine(OrderBook::new(pair.clone()))
        .join();
    let g2 = matcher2.groups().with_key(group_key)
        .with_state_machine(OrderBook::new(pair.clone()))
        .join();

    // Wait for consensus to elect a leader
    g0.when().online().await;
    g1.when().online().await;
    g2.when().online().await;</code></pre>
<h3 id="connecting-traders-via-streams"><a class="header" href="#connecting-traders-via-streams">Connecting Traders via Streams</a></h3>
<pre><code class="language-rust ignore">    // --- 2 trader nodes producing orders ---
    let trader_a = Network::new(network_id).await?;
    let trader_b = Network::new(network_id).await?;
    discover_all([&amp;trader_a, &amp;trader_b, &amp;matcher0, &amp;matcher1, &amp;matcher2]).await?;

    // Traders produce Order streams
    let mut orders_a = trader_a.streams().produce::&lt;Order&gt;();
    let mut orders_b = trader_b.streams().produce::&lt;Order&gt;();

    // Matcher consumes orders
    let mut order_consumer = matcher0.streams().consume::&lt;Order&gt;();
    order_consumer.when().subscribed().minimum_of(2).await;</code></pre>
<h3 id="submitting-and-matching-orders"><a class="header" href="#submitting-and-matching-orders">Submitting and Matching Orders</a></h3>
<pre><code class="language-rust ignore">    // Trader A: asks (selling ETH)
    orders_a.send(Order {
        id: 1, pair: pair.clone(), side: Side::Ask,
        price: 300_000, quantity: 10, trader: "alice".into(),
    }).await?;

    // Trader B: bids (buying ETH)
    orders_b.send(Order {
        id: 4, pair: pair.clone(), side: Side::Bid,
        price: 300_500, quantity: 15, trader: "bob".into(),
    }).await?;

    // Consume orders from stream and execute through Raft
    for _ in 0..4 {
        let order = order_consumer.next().await
            .expect("expected order from stream");
        g0.execute(OrderBookCommand::PlaceOrder(order)).await?;
    }</code></pre>
<h3 id="querying-results"><a class="header" href="#querying-results">Querying Results</a></h3>
<pre><code class="language-rust ignore">    // Query fills (strong consistency — goes through leader)
    let result = g0.query(OrderBookQuery::Fills, Consistency::Strong).await?;
    if let OrderBookQueryResult::Fills(fills) = result.result() {
        for fill in fills {
            println!("{fill}");
        }
    }

    // Verify replication to followers
    g1.when().committed().reaches(g0.committed()).await;
    let follower_result = g1.query(
        OrderBookQuery::Fills, Consistency::Weak
    ).await?;</code></pre>
<p>Key patterns demonstrated:</p>
<ul>
<li><strong><code>execute()</code></strong> — sends a command through Raft and waits for it to be committed on a quorum</li>
<li><strong><code>query(..., Strong)</code></strong> — reads through the leader for linearizable results</li>
<li><strong><code>query(..., Weak)</code></strong> — reads local state (faster, but may be stale)</li>
<li><strong><code>when().committed().reaches(n)</code></strong> — waits for a follower to catch up to a specific commit index</li>
</ul>
<h2 id="the-helper-cross-discovery"><a class="header" href="#the-helper-cross-discovery">The Helper: Cross-Discovery</a></h2>
<p>The example includes a utility to fully connect all nodes:</p>
<pre><code class="language-rust ignore">async fn discover_all(
    networks: impl IntoIterator&lt;Item = &amp;Network&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    let networks = networks.into_iter().collect::&lt;Vec&lt;_&gt;&gt;();
    for (i, net_i) in networks.iter().enumerate() {
        for (j, net_j) in networks.iter().enumerate() {
            if i != j {
                net_i.discovery().sync_with(net_j.local().addr()).await?;
            }
        }
    }
    Ok(())
}</code></pre>
<p>In production, this pairwise sync is unnecessary — a single bootstrap peer handles discovery via gossip. This utility is for testing where all nodes start simultaneously.</p>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the Example</a></h2>
<pre><code class="language-bash">cd examples/orderbook
cargo run
</code></pre>
<p>Expected output:</p>
<pre><code class="language-text">waiting for matching engine group to come online...
matching engine online, leader: &lt;peer-id&gt;
matcher subscribed to both trader order streams
submitting orders...
received order: alice ASK ETH/USDC@300000 qty=10
received order: alice ASK ETH/USDC@301000 qty=5
received order: bob BID ETH/USDC@299000 qty=8
received order: bob BID ETH/USDC@300500 qty=15
1 fills produced:
  Fill(bid=4, ask=1, ETH/USDC@300000, qty=10)
follower g1 sees 1 fills (consistent with leader)
orderbook example complete
</code></pre>
<h2 id="key-takeaways-1"><a class="header" href="#key-takeaways-1">Key Takeaways</a></h2>
<ol>
<li><strong>Streams for data ingestion</strong> — orders flow from traders to the matching engine via typed pub/sub</li>
<li><strong>Raft for consensus</strong> — the <code>OrderBook</code> state machine runs on all replicas with identical results because Raft guarantees the same command order</li>
<li><strong><code>execute()</code> for writes, <code>query()</code> for reads</strong> — clean separation between mutations (replicated) and reads (local or forwarded)</li>
<li><strong>Automatic catch-up</strong> — new replicas replay the command log to reach the current state</li>
<li><strong>Composability</strong> — Streams + Groups + StateMachine combine naturally for real distributed applications</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="network-1"><a class="header" href="#network-1">Network</a></h1>
<p>The <code>Network</code> is the primary entry point to the mosaik SDK. It creates the QUIC transport layer, establishes node identity, and composes all subsystems (Discovery, Streams, Groups) into a single cohesive runtime.</p>
<h2 id="creating-a-network"><a class="header" href="#creating-a-network">Creating a Network</a></h2>
<h3 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h3>
<p>For prototyping, <code>Network::new()</code> creates a node with default settings:</p>
<pre><code class="language-rust ignore">use mosaik::{Network, NetworkId};

let network = Network::new("my-app".into()).await?;</code></pre>
<p>This creates a node with:</p>
<ul>
<li>A random secret key (new identity each run)</li>
<li>Default relay mode (iroh’s relay servers for NAT traversal)</li>
<li>No bootstrap peers</li>
<li>No tags</li>
<li>Default configs for all subsystems</li>
</ul>
<h3 id="builder-pattern-1"><a class="header" href="#builder-pattern-1">Builder Pattern</a></h3>
<p>For production use, the builder provides full control:</p>
<pre><code class="language-rust ignore">use mosaik::{Network, NetworkId, discovery, streams, groups};
use iroh::SecretKey;

let network = Network::builder("my-app".into())
    .with_secret_key(my_secret_key)
    .with_relay_mode(iroh::RelayMode::Disabled)
    .with_mdns_discovery(true)
    .with_addresses(bind_addrs)
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
            .with_tags("my-role")
            .with_purge_after(Duration::from_secs(600))
    )
    .with_streams(
        streams::Config::builder()
    )
    .with_groups(
        groups::Config::builder()
    )
    .build()
    .await?;</code></pre>
<h3 id="builder-options"><a class="header" href="#builder-options">Builder Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>with_secret_key()</code></td><td><code>SecretKey</code></td><td>Random</td><td>Node identity (determines <code>PeerId</code>)</td></tr>
<tr><td><code>with_relay_mode()</code></td><td><code>RelayMode</code></td><td><code>Default</code></td><td>NAT traversal via relay servers</td></tr>
<tr><td><code>with_mdns_discovery()</code></td><td><code>bool</code></td><td><code>false</code></td><td>Local network mDNS peer discovery</td></tr>
<tr><td><code>with_addresses()</code></td><td><code>BTreeSet&lt;SocketAddr&gt;</code></td><td>Empty</td><td>Explicit bind addresses</td></tr>
<tr><td><code>with_discovery()</code></td><td><code>ConfigBuilder</code></td><td>Defaults</td><td>Discovery subsystem configuration</td></tr>
<tr><td><code>with_streams()</code></td><td><code>ConfigBuilder</code></td><td>Defaults</td><td>Streams subsystem configuration</td></tr>
<tr><td><code>with_groups()</code></td><td><code>ConfigBuilder</code></td><td>Defaults</td><td>Groups subsystem configuration</td></tr>
</tbody>
</table>
</div>
<h2 id="accessing-subsystems"><a class="header" href="#accessing-subsystems">Accessing Subsystems</a></h2>
<p>Once built, the <code>Network</code> provides access to all subsystems:</p>
<pre><code class="language-rust ignore">// Transport &amp; identity
let local = network.local();
let peer_id = network.local().id();
let addr = network.local().addr();
let network_id = network.network_id();

// Subsystems
let discovery = network.discovery();
let streams = network.streams();
let groups = network.groups();</code></pre>
<p>All handles are cheap to clone (<code>Arc&lt;Inner&gt;</code> internally).</p>
<h2 id="localnode"><a class="header" href="#localnode">LocalNode</a></h2>
<p><code>LocalNode</code> represents the local node’s transport and identity:</p>
<pre><code class="language-rust ignore">let local = network.local();

// Identity
let peer_id = local.id();          // Public key
let secret = local.secret_key();   // Secret key
let network_id = local.network_id();

// Address (for sharing with others)
let addr = local.addr();  // EndpointAddr: public key + relay URL + addrs

// Readiness
local.online().await;  // Blocks until the endpoint is ready

// Low-level access to iroh endpoint
let endpoint = local.endpoint();</code></pre>
<h2 id="waiting-for-readiness"><a class="header" href="#waiting-for-readiness">Waiting for Readiness</a></h2>
<p>After building, you can wait for the node to be fully online:</p>
<pre><code class="language-rust ignore">network.online().await;</code></pre>
<p>This resolves once the iroh endpoint is ready and all subsystem handlers are installed. The <code>build()</code> method already waits for this, so <code>online()</code> is mainly useful when you have a cloned network handle.</p>
<h2 id="lifecycle--shutdown-1"><a class="header" href="#lifecycle--shutdown-1">Lifecycle &amp; Shutdown</a></h2>
<p>When a <code>Network</code> is dropped, it cancels the internal <code>CancellationToken</code>, which propagates shutdown to all subsystems:</p>
<pre><code class="language-rust ignore">{
    let network = Network::new(network_id).await?;
    // Node is running...
} // Network dropped here → all tasks cancelled</code></pre>
<p>For long-running services, keep the network handle alive:</p>
<pre><code class="language-rust ignore">let network = Network::new(network_id).await?;
// ... set up streams, groups, etc.
core::future::pending::&lt;()&gt;().await;  // Block forever</code></pre>
<h2 id="link-the-wire-protocol"><a class="header" href="#link-the-wire-protocol">Link: The Wire Protocol</a></h2>
<p>Under the hood, all communication happens through <code>Link&lt;P&gt;</code> — a typed, framed, bidirectional QUIC stream:</p>
<pre><code class="language-rust ignore">pub struct Link&lt;P: Protocol&gt; { /* ... */ }</code></pre>
<p>Links provide:</p>
<ul>
<li><strong>Length-delimited framing</strong> via <code>LengthDelimitedCodec</code></li>
<li><strong>Serialization</strong> via <code>postcard</code> (compact binary format)</li>
<li><strong>Type safety</strong> via the <code>Protocol</code> trait and generic parameter</li>
</ul>
<pre><code class="language-rust ignore">// Open a link to a remote peer
let link = Link::&lt;MyProtocol&gt;::open(local, remote_addr).await?;

// Send and receive typed messages
link.send(MyMessage { /* ... */ }).await?;
let response: MyResponse = link.recv().await?;

// Split into independent halves
let (sender, receiver) = link.split();

// Close with a typed reason
link.close(MyCloseReason::Success).await?;</code></pre>
<p>Most users won’t use <code>Link</code> directly — it’s the building block that Streams, Groups, and Discovery use internally.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Network construction can fail with:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Cause</th></tr>
</thead>
<tbody>
<tr><td><code>MissingNetworkId</code></td><td>Network ID not provided</td></tr>
<tr><td><code>Bind(BindError)</code></td><td>Failed to bind the QUIC endpoint</td></tr>
<tr><td><code>InvalidAddress</code></td><td>Invalid socket address in configuration</td></tr>
<tr><td><code>DiscoveryConfig(...)</code></td><td>Invalid discovery configuration</td></tr>
<tr><td><code>StreamsConfig(...)</code></td><td>Invalid streams configuration</td></tr>
<tr><td><code>GroupsConfig(...)</code></td><td>Invalid groups configuration</td></tr>
</tbody>
</table>
</div>
<p>Connection-level errors use typed close reasons:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Name</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>200</td><td><code>Success</code></td><td>Protocol completed normally</td></tr>
<tr><td>204</td><td><code>GracefulShutdown</code></td><td>Clean shutdown</td></tr>
<tr><td>100</td><td><code>InvalidAlpn</code></td><td>Wrong protocol identifier</td></tr>
<tr><td>101</td><td><code>DifferentNetwork</code></td><td>Peer on a different network</td></tr>
<tr><td>102</td><td><code>Cancelled</code></td><td>Operation cancelled</td></tr>
<tr><td>400</td><td><code>ProtocolViolation</code></td><td>Message deserialization failed</td></tr>
<tr><td>401</td><td><code>UnknownPeer</code></td><td>Peer not in discovery catalog</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="discovery-1"><a class="header" href="#discovery-1">Discovery</a></h1>
<p>The Discovery subsystem handles gossip-based peer discovery and catalog synchronization. It maintains a network-wide view of all peers, their capabilities, and their available streams and groups.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Discovery uses three complementary mechanisms:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mechanism</th><th>Transport</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>DHT Bootstrap</td><td>Mainline DHT (pkarr)</td><td>Automatic peer discovery via shared <code>NetworkId</code></td></tr>
<tr><td>Announce</td><td><code>/mosaik/announce</code></td><td>Real-time gossip broadcasts via iroh-gossip</td></tr>
<tr><td>Catalog Sync</td><td><code>/mosaik/catalog-sync</code></td><td>Full bidirectional catalog exchange for catch-up</td></tr>
</tbody>
</table>
</div>
<p>Nodes sharing the same <code>NetworkId</code> automatically discover each other through the DHT — no hardcoded bootstrap peers are required. Once an initial connection is established, the Announce and Catalog Sync protocols take over for real-time updates.</p>
<p>See the <a href="#dht-bootstrap">DHT Bootstrap</a> sub-chapter for details on the automatic discovery mechanism.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Configure discovery through the <code>Network</code> builder:</p>
<pre><code class="language-rust ignore">use mosaik::{Network, discovery};
use std::time::Duration;

let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            .with_bootstrap(bootstrap_addr)
            .with_tags("matcher")
            .with_tags(["validator", "signer"])  // additive
            .with_purge_after(Duration::from_secs(600))
            .with_announce_interval(Duration::from_secs(10))
            .with_announce_jitter(0.3)
            .with_max_time_drift(Duration::from_secs(5))
            .with_events_backlog(200)
    )
    .build()
    .await?;</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bootstrap_peers</code></td><td><code>[]</code></td><td>Initial peers to connect to on startup</td></tr>
<tr><td><code>tags</code></td><td><code>[]</code></td><td>Tags to advertise about this node</td></tr>
<tr><td><code>announce_interval</code></td><td>15s</td><td>How often to re-announce via gossip</td></tr>
<tr><td><code>announce_jitter</code></td><td>0.5</td><td>Max jitter factor (0.0–1.0) for announce timing</td></tr>
<tr><td><code>purge_after</code></td><td>300s</td><td>Duration after which stale entries are purged</td></tr>
<tr><td><code>max_time_drift</code></td><td>10s</td><td>Maximum acceptable clock drift between peers</td></tr>
<tr><td><code>events_backlog</code></td><td>100</td><td>Past events retained in event broadcast channel</td></tr>
<tr><td><code>dht_publish_interval</code></td><td>300s</td><td>How often to publish to the DHT (<code>None</code> to disable)</td></tr>
<tr><td><code>dht_poll_interval</code></td><td>60s</td><td>How often to poll the DHT for peers (<code>None</code> to disable)</td></tr>
</tbody>
</table>
</div>
<p>Both <code>with_bootstrap()</code> and <code>with_tags()</code> are <strong>additive</strong> — calling them multiple times adds to the list.</p>
<h2 id="accessing-discovery"><a class="header" href="#accessing-discovery">Accessing Discovery</a></h2>
<pre><code class="language-rust ignore">let discovery = network.discovery();</code></pre>
<p>The <code>Discovery</code> handle is cheap to clone.</p>
<h2 id="core-api"><a class="header" href="#core-api">Core API</a></h2>
<h3 id="catalog-access"><a class="header" href="#catalog-access">Catalog Access</a></h3>
<pre><code class="language-rust ignore">// Get current snapshot of all known peers
let catalog = discovery.catalog();
for (peer_id, entry) in catalog.iter() {
    println!("{}: tags={:?}", peer_id, entry.tags);
}

// Watch for catalog changes
let mut watch = discovery.catalog_watch();
loop {
    watch.changed().await?;
    let catalog = watch.borrow();
    println!("Catalog updated: {} peers", catalog.len());
}</code></pre>
<h3 id="dialing-peers"><a class="header" href="#dialing-peers">Dialing Peers</a></h3>
<pre><code class="language-rust ignore">// Connect to bootstrap peers manually
discovery.dial(bootstrap_addr);

// Dial multiple peers
discovery.dial([addr1, addr2, addr3]);</code></pre>
<h3 id="manual-sync"><a class="header" href="#manual-sync">Manual Sync</a></h3>
<pre><code class="language-rust ignore">// Trigger a full catalog sync with a specific peer
discovery.sync_with(peer_addr).await?;</code></pre>
<h3 id="managing-tags"><a class="header" href="#managing-tags">Managing Tags</a></h3>
<pre><code class="language-rust ignore">// Add tags at runtime
discovery.add_tags("new-role");
discovery.add_tags(["role-a", "role-b"]);

// Remove tags
discovery.remove_tags("old-role");</code></pre>
<p>Changing tags triggers an immediate re-announcement to the network.</p>
<h3 id="local-entry"><a class="header" href="#local-entry">Local Entry</a></h3>
<pre><code class="language-rust ignore">// Get this node's signed entry (as others see it)
let my_entry = discovery.me();
println!("I am: {:?}", my_entry);</code></pre>
<h3 id="unsigned-entries"><a class="header" href="#unsigned-entries">Unsigned Entries</a></h3>
<p>For testing or manual feeds, you can insert entries that aren’t cryptographically signed:</p>
<pre><code class="language-rust ignore">use mosaik::discovery::PeerEntry;

// Insert an unsigned entry (local-only, not gossiped)
discovery.insert(PeerEntry { /* ... */ });

// Remove a specific peer
discovery.remove(peer_id);

// Clear all unsigned entries
discovery.clear_unsigned();</code></pre>
<h3 id="injecting-signed-entries"><a class="header" href="#injecting-signed-entries">Injecting Signed Entries</a></h3>
<pre><code class="language-rust ignore">// Feed a signed entry from an external source
let success = discovery.feed(signed_peer_entry);</code></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Subscribe to discovery lifecycle events:</p>
<pre><code class="language-rust ignore">let mut events = discovery.events();
while let Ok(event) = events.recv().await {
    match event {
        Event::PeerDiscovered(entry) =&gt; {
            println!("New peer: {}", entry.peer_id());
        }
        Event::PeerUpdated(entry) =&gt; {
            println!("Peer updated: {}", entry.peer_id());
        }
        Event::PeerDeparted(peer_id) =&gt; {
            println!("Peer left: {}", peer_id);
        }
    }
}</code></pre>
<p>See the <a href="#events-1">Events</a> sub-chapter for details.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<h3 id="announce-protocol"><a class="header" href="#announce-protocol">Announce Protocol</a></h3>
<p>Every node periodically broadcasts its <code>SignedPeerEntry</code> via iroh-gossip. The announce includes:</p>
<ul>
<li>Node identity (PeerId)</li>
<li>Network ID</li>
<li>Tags</li>
<li>Available streams and groups</li>
<li>Version (start + update timestamps)</li>
</ul>
<p>The jitter on the announce interval prevents all nodes from announcing simultaneously. When a node changes its metadata (adds a tag, creates a stream, joins a group), it re-announces immediately.</p>
<h3 id="catalog-sync-protocol"><a class="header" href="#catalog-sync-protocol">Catalog Sync Protocol</a></h3>
<p>When a new node connects to a peer, they exchange their full catalogs bidirectionally. This ensures a new node quickly learns about all existing peers without waiting for gossip cycles.</p>
<h3 id="signed-vs-unsigned-entries"><a class="header" href="#signed-vs-unsigned-entries">Signed vs Unsigned Entries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Signed</th><th>Unsigned</th></tr>
</thead>
<tbody>
<tr><td>Source</td><td>Created by the peer itself</td><td>Injected locally</td></tr>
<tr><td>Verification</td><td>Cryptographic signature</td><td>None</td></tr>
<tr><td>Gossip</td><td>Yes — propagated network-wide</td><td>No — local only</td></tr>
<tr><td>Use case</td><td>Normal operation</td><td>Testing, manual feeds</td></tr>
</tbody>
</table>
</div>
<h3 id="staleness-detection"><a class="header" href="#staleness-detection">Staleness Detection</a></h3>
<p>Each entry has a two-part version: <code>(start_timestamp, update_timestamp)</code>. If <code>update_timestamp</code> falls behind the current time by more than <code>purge_after</code>, the entry is hidden from the public catalog API and eventually removed.</p>
<p>See the <a href="#catalog">Catalog</a> sub-chapter for the full catalog API.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dht-bootstrap"><a class="header" href="#dht-bootstrap">DHT Bootstrap</a></h1>
<p>Mosaik includes an automatic peer discovery mechanism based on the <a href="https://en.wikipedia.org/wiki/Mainline_DHT">Mainline DHT</a> (the same DHT used by BitTorrent). Nodes sharing the same <code>NetworkId</code> automatically discover each other — no hardcoded bootstrap peers are needed.</p>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<p>Each node derives a DHT key from its <code>NetworkId</code> and uses it to both <strong>publish</strong> its own address and <strong>poll</strong> for other nodes’ addresses. The general flow is:</p>
<ol>
<li><strong>Publish</strong> — The node resolves the current DHT record for the network key, appends its own address, and publishes the updated record back to the DHT.</li>
<li><strong>Poll</strong> — The node periodically reads the DHT record and dials any peers it finds.</li>
</ol>
<p>Because both publish and poll use the same deterministic key derived from the <code>NetworkId</code>, all nodes in the same network naturally converge on the same record.</p>
<h3 id="record-structure"><a class="header" href="#record-structure">Record Structure</a></h3>
<p>Each DHT record is a <a href="https://pkarr.org">pkarr</a> signed packet containing DNS resource records. Every peer in the record has:</p>
<ul>
<li>An <strong>A record</strong> with a unique subdomain to identify the peer</li>
<li>A <strong>TXT record</strong> with a <code>peers=N</code> field indicating how many peers that node currently knows about</li>
</ul>
<h3 id="capacity-management"><a class="header" href="#capacity-management">Capacity Management</a></h3>
<p>Mainline DHT records are limited to 1000 bytes. To stay within this limit, a maximum of <strong>12 peers</strong> are stored per record. When the record is full and a new node needs to publish, the <strong>least-connected peer</strong> (the one with the lowest <code>peers=N</code> count) is evicted. Ties are broken randomly to avoid deterministic starvation.</p>
<p>Evicted peers are not forgotten — they are dialed directly so they can still join the network through normal gossip-based discovery.</p>
<h3 id="adaptive-polling"><a class="header" href="#adaptive-polling">Adaptive Polling</a></h3>
<p>Polling uses an adaptive interval:</p>
<ul>
<li><strong>Aggressive polling (5 seconds)</strong> — when the node has no known peers yet, it polls frequently to bootstrap quickly.</li>
<li><strong>Relaxed polling (configurable, default 60 seconds)</strong> — once the node has discovered at least one peer, polling slows down to reduce DHT load.</li>
</ul>
<h3 id="publish-cycle"><a class="header" href="#publish-cycle">Publish Cycle</a></h3>
<p>Publishing runs on a slower interval (default <strong>5 minutes</strong>) and uses <strong>compare-and-swap (CAS)</strong> to safely update the shared record without overwriting concurrent changes from other nodes. A random startup jitter prevents all nodes from publishing simultaneously.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>DHT bootstrap is <strong>enabled by default</strong>. You can tune the intervals or disable it entirely:</p>
<pre><code class="language-rust ignore">use mosaik::{Network, discovery};
use std::time::Duration;

let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            // Customize DHT intervals
            .with_dht_publish_interval(Some(Duration::from_secs(300)))
            .with_dht_poll_interval(Some(Duration::from_secs(60)))
    )
    .build()
    .await?;</code></pre>
<p>To disable automatic bootstrap (e.g., when using only explicit bootstrap peers):</p>
<pre><code class="language-rust ignore">let network = Network::builder(network_id)
    .with_discovery(
        discovery::Config::builder()
            .no_auto_bootstrap()
            .with_bootstrap(bootstrap_addr)  // use explicit peers instead
    )
    .build()
    .await?;</code></pre>
<h3 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dht_publish_interval</code></td><td>300s</td><td>How often to publish this node’s address to the DHT. <code>None</code> disables publishing.</td></tr>
<tr><td><code>dht_poll_interval</code></td><td>60s</td><td>How often to poll the DHT for new peers. <code>None</code> disables polling. Actual interval is adaptive (5s when no peers are known).</td></tr>
</tbody>
</table>
</div>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p>DHT bootstrap is ideal for:</p>
<ul>
<li><strong>Decentralized deployments</strong> where there is no fixed infrastructure to serve as bootstrap nodes</li>
<li><strong>Dynamic environments</strong> where nodes come and go frequently</li>
<li><strong>Zero-configuration setups</strong> where nodes only need to agree on a network name</li>
</ul>
<p>For networks with stable infrastructure, you can combine DHT bootstrap with explicit bootstrap peers — nodes will use whichever method finds peers first.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="catalog"><a class="header" href="#catalog">Catalog</a></h1>
<p>The <code>Catalog</code> is an immutable snapshot of all discovered peers in the network. It’s thread-safe, cheap to clone, and updated via <code>watch</code> channels.</p>
<h2 id="getting-a-catalog"><a class="header" href="#getting-a-catalog">Getting a Catalog</a></h2>
<pre><code class="language-rust ignore">let catalog = network.discovery().catalog();</code></pre>
<p>Each call returns a snapshot — it won’t change after you’ve obtained it. To observe changes, use the watch channel.</p>
<h2 id="catalog-api"><a class="header" href="#catalog-api">Catalog API</a></h2>
<h3 id="iterating-peers"><a class="header" href="#iterating-peers">Iterating Peers</a></h3>
<pre><code class="language-rust ignore">let catalog = discovery.catalog();

// Iterate all peers
for (peer_id, entry) in catalog.iter() {
    println!("Peer {}: {:?}", peer_id, entry.tags);
}

// Count peers
println!("Known peers: {}", catalog.len());</code></pre>
<h3 id="watching-for-changes"><a class="header" href="#watching-for-changes">Watching for Changes</a></h3>
<pre><code class="language-rust ignore">let mut watch = discovery.catalog_watch();

loop {
    // Wait for catalog to change
    watch.changed().await?;

    // Borrow the latest snapshot
    let catalog = watch.borrow();
    println!("Catalog updated, {} peers", catalog.len());
}</code></pre>
<p>The watch receiver always has the latest value. Multiple calls to <code>changed()</code> may skip intermediate updates if the catalog changes faster than you observe it.</p>
<h2 id="peerentry"><a class="header" href="#peerentry">PeerEntry</a></h2>
<p>Each peer in the catalog is represented by a <code>PeerEntry</code>:</p>
<pre><code class="language-rust ignore">pub struct PeerEntry {
    pub network_id: NetworkId,
    pub peer_id: PeerId,
    pub addr: EndpointAddr,
    pub tags: BTreeSet&lt;Tag&gt;,
    pub streams: BTreeSet&lt;StreamId&gt;,
    pub groups: BTreeSet&lt;GroupId&gt;,
    pub version: PeerEntryVersion,
}</code></pre>
<h3 id="fields"><a class="header" href="#fields">Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>network_id</code></td><td><code>NetworkId</code></td><td>Which network this peer belongs to</td></tr>
<tr><td><code>peer_id</code></td><td><code>PeerId</code></td><td>The peer’s public key</td></tr>
<tr><td><code>addr</code></td><td><code>EndpointAddr</code></td><td>Connection address (public key + relay + direct addrs)</td></tr>
<tr><td><code>tags</code></td><td><code>BTreeSet&lt;Tag&gt;</code></td><td>Capability labels (e.g., <code>"matcher"</code>, <code>"validator"</code>)</td></tr>
<tr><td><code>streams</code></td><td><code>BTreeSet&lt;StreamId&gt;</code></td><td>Streams this peer produces</td></tr>
<tr><td><code>groups</code></td><td><code>BTreeSet&lt;GroupId&gt;</code></td><td>Groups this peer belongs to</td></tr>
<tr><td><code>version</code></td><td><code>PeerEntryVersion</code></td><td>Two-part version for staleness detection</td></tr>
</tbody>
</table>
</div>
<h3 id="signed-entries-1"><a class="header" href="#signed-entries-1">Signed Entries</a></h3>
<p>In practice, most catalog entries are <code>SignedPeerEntry</code> — a <code>PeerEntry</code> with a cryptographic signature proving the owner created it:</p>
<pre><code class="language-rust ignore">let my_entry: SignedPeerEntry = discovery.me();
let peer_id = my_entry.peer_id();</code></pre>
<h2 id="version--staleness"><a class="header" href="#version--staleness">Version &amp; Staleness</a></h2>
<p>Each entry carries a two-part version:</p>
<pre><code class="language-rust ignore">pub struct PeerEntryVersion {
    pub start: Timestamp,   // When the peer first came online
    pub update: Timestamp,  // When the entry was last updated
}</code></pre>
<p>Entries where <code>update</code> is older than <code>purge_after</code> (default: 300s) are considered stale. Stale entries are:</p>
<ol>
<li><strong>Hidden</strong> from the public catalog API</li>
<li><strong>Eventually removed</strong> if not refreshed</li>
</ol>
<p>The periodic gossip re-announce (every ~15s by default) keeps entries fresh. When a node departs gracefully, it broadcasts a departure message; ungraceful departures are detected by staleness.</p>
<h2 id="using-catalog-for-filtering"><a class="header" href="#using-catalog-for-filtering">Using Catalog for Filtering</a></h2>
<p>The catalog is commonly used to filter peers in Streams:</p>
<pre><code class="language-rust ignore">// Producer: only accept consumers with specific tags
let producer = network.streams().producer::&lt;Order&gt;()
    .accept_if(|peer| peer.tags.contains(&amp;"authorized".into()))
    .build()?;

// Consumer: only subscribe to specific producers
let consumer = network.streams().consumer::&lt;Order&gt;()
    .subscribe_if(|peer| peer.tags.contains(&amp;"primary".into()))
    .build();</code></pre>
<h2 id="internal-structure"><a class="header" href="#internal-structure">Internal Structure</a></h2>
<p>The catalog uses <code>im::OrdMap</code> — an immutable, persistent ordered map — for its internal storage. This provides:</p>
<ul>
<li><strong>O(1) cloning</strong> — snapshots are effectively free</li>
<li><strong>Consistent iteration order</strong> — deterministic across nodes</li>
<li><strong>Thread safety</strong> — immutable snapshots can be shared freely</li>
</ul>
<p>Updates create new snapshots atomically via <code>tokio::sync::watch::Sender&lt;Catalog&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<p>The Discovery subsystem emits events when the peer catalog changes. You can subscribe to these events for reactive programming.</p>
<h2 id="subscribing-to-events"><a class="header" href="#subscribing-to-events">Subscribing to Events</a></h2>
<pre><code class="language-rust ignore">let mut events = network.discovery().events();

while let Ok(event) = events.recv().await {
    match event {
        Event::PeerDiscovered(entry) =&gt; {
            println!("New peer joined: {}", entry.peer_id());
        }
        Event::PeerUpdated(entry) =&gt; {
            println!("Peer updated: {}", entry.peer_id());
        }
        Event::PeerDeparted(peer_id) =&gt; {
            println!("Peer departed: {}", peer_id);
        }
    }
}</code></pre>
<p>The <code>events()</code> method returns a <code>tokio::sync::broadcast::Receiver&lt;Event&gt;</code>. Multiple consumers can subscribe independently.</p>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<h3 id="peerdiscovered"><a class="header" href="#peerdiscovered">PeerDiscovered</a></h3>
<p>Emitted when a previously unknown peer is added to the catalog:</p>
<pre><code class="language-rust ignore">Event::PeerDiscovered(signed_peer_entry)</code></pre>
<p>This fires for both signed entries (from gossip/sync) and unsigned entries (from manual <code>insert()</code>).</p>
<h3 id="peerupdated"><a class="header" href="#peerupdated">PeerUpdated</a></h3>
<p>Emitted when an existing peer’s entry changes:</p>
<pre><code class="language-rust ignore">Event::PeerUpdated(signed_peer_entry)</code></pre>
<p>Common triggers:</p>
<ul>
<li>Peer added or removed tags</li>
<li>Peer started or stopped producing a stream</li>
<li>Peer joined or left a group</li>
<li>Peer’s address changed</li>
</ul>
<h3 id="peerdeparted"><a class="header" href="#peerdeparted">PeerDeparted</a></h3>
<p>Emitted when a peer is removed from the catalog:</p>
<pre><code class="language-rust ignore">Event::PeerDeparted(peer_id)</code></pre>
<p>This fires when:</p>
<ul>
<li>A peer’s entry becomes stale and is purged</li>
<li>A peer gracefully departs via the departure protocol</li>
<li>An unsigned entry is removed via <code>discovery.remove(peer_id)</code></li>
</ul>
<h2 id="backlog"><a class="header" href="#backlog">Backlog</a></h2>
<p>The event channel retains up to <code>events_backlog</code> (default: 100) past events. If a consumer falls behind, older events are dropped and the consumer receives a <code>RecvError::Lagged(n)</code> indicating how many events were missed.</p>
<pre><code class="language-rust ignore">match events.recv().await {
    Ok(event) =&gt; { /* handle event */ }
    Err(broadcast::error::RecvError::Lagged(n)) =&gt; {
        tracing::warn!("Missed {n} events, consider full catalog re-read");
        let catalog = discovery.catalog();
        // Reconcile from snapshot
    }
    Err(broadcast::error::RecvError::Closed) =&gt; break,
}</code></pre>
<h2 id="catalog-watch-vs-events"><a class="header" href="#catalog-watch-vs-events">Catalog Watch vs Events</a></h2>
<p>Choose the right tool:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Tool</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>React to specific changes</td><td><code>events()</code></td><td>Get individual events with full context</td></tr>
<tr><td>Get current state</td><td><code>catalog()</code></td><td>Snapshot of all peers</td></tr>
<tr><td>React to any change</td><td><code>catalog_watch()</code></td><td>Triggered on every update, borrow latest</td></tr>
<tr><td>Build a UI dashboard</td><td><code>catalog_watch()</code></td><td>Re-render on changes, read full state</td></tr>
<tr><td>Log peer arrivals/departures</td><td><code>events()</code></td><td>Specific events about each peer</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="streams-1"><a class="header" href="#streams-1">Streams</a></h1>
<p>Streams are the primary dataflow primitive in mosaik. They represent typed, asynchronous data channels that connect <strong>producers</strong> and <strong>consumers</strong> across a network.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<pre><code>Producer Node                       Consumer Node
┌─────────────────┐                ┌─────────────────┐
│  Producer&lt;D&gt;    │────QUIC────────│  Consumer&lt;D&gt;     │
│  (Sink impl)    │  /mosaik/      │  (Stream impl)   │
│                 │  streams/1.0   │                   │
└─────────────────┘                └─────────────────┘
</code></pre>
<p>A producer announces a stream via Discovery. Consumers discover the producer, open a QUIC connection using the <code>/mosaik/streams/1.0</code> ALPN, and begin receiving data. The entire lifecycle is automatic — you only create the handles.</p>
<h2 id="the-datum-trait"><a class="header" href="#the-datum-trait">The Datum Trait</a></h2>
<p>Every type sent through a stream must implement <code>Datum</code>:</p>
<pre><code class="language-rust ignore">pub trait Datum: Serialize + DeserializeOwned + Send + 'static {
    fn derived_stream_id() -&gt; StreamId {
        core::any::type_name::&lt;Self&gt;().into()
    }
}</code></pre>
<p><code>Datum</code> is a blanket impl — any <code>Serialize + DeserializeOwned + Send + 'static</code> type is automatically a <code>Datum</code>. The <code>derived_stream_id()</code> method computes a <code>StreamId</code> (a <code>Digest</code>) from the Rust type name, so each type naturally maps to a unique stream.</p>
<pre><code class="language-rust ignore">#[derive(Serialize, Deserialize)]
struct PriceUpdate {
    symbol: String,
    price: f64,
}

// PriceUpdate is automatically a Datum
// StreamId = blake3("my_crate::PriceUpdate")</code></pre>
<h2 id="quick-usage"><a class="header" href="#quick-usage">Quick Usage</a></h2>
<p><strong>Producing data:</strong></p>
<pre><code class="language-rust ignore">let producer = network.streams().produce::&lt;PriceUpdate&gt;();

// Wait until at least one consumer is connected
producer.when().online().await;

// Send via Sink trait
use futures::SinkExt;
producer.send(PriceUpdate { symbol: "ETH".into(), price: 3200.0 }).await?;

// Or send immediately (non-blocking)
producer.try_send(PriceUpdate { symbol: "BTC".into(), price: 65000.0 })?;</code></pre>
<p><strong>Consuming data:</strong></p>
<pre><code class="language-rust ignore">let mut consumer = network.streams().consume::&lt;PriceUpdate&gt;();

// Wait until connected to at least one producer
consumer.when().online().await;

// Receive via async method
while let Some(update) = consumer.recv().await {
    println!("{}: ${}", update.symbol, update.price);
}

// Or use as a futures::Stream
use futures::StreamExt;
while let Some(update) = consumer.next().await {
    println!("{}: ${}", update.symbol, update.price);
}</code></pre>
<h2 id="stream-identity"><a class="header" href="#stream-identity">Stream Identity</a></h2>
<p>By default, a stream’s identity comes from <code>Datum::derived_stream_id()</code>, which hashes the Rust type name. You can override this with a custom <code>StreamId</code>:</p>
<pre><code class="language-rust ignore">let producer = network.streams()
    .producer::&lt;PriceUpdate&gt;()
    .with_stream_id("custom-price-feed")
    .build()?;</code></pre>
<p>This lets you have multiple distinct streams of the same data type.</p>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>Streams are built on top of the Discovery and Network subsystems:</p>
<ol>
<li><strong>Producer creation</strong> — the local discovery entry is updated to advertise the stream</li>
<li><strong>Consumer creation</strong> — the consumer worker discovers producers via the catalog and opens subscriptions</li>
<li><strong>Subscription</strong> — a QUIC bi-directional stream is opened; the consumer sends its <code>Criteria</code>, the producer sends data</li>
<li><strong>Fanout</strong> — each consumer gets its own independent sender loop so a slow consumer does not block others</li>
<li><strong>Cleanup</strong> — when handles are dropped, underlying tasks are cancelled</li>
</ol>
<h2 id="close-reason-codes"><a class="header" href="#close-reason-codes">Close Reason Codes</a></h2>
<p>When a stream subscription fails, the producer sends structured close reasons:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Name</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>10_404</code></td><td><code>StreamNotFound</code></td><td>The requested stream does not exist on the producer</td></tr>
<tr><td><code>10_403</code></td><td><code>NotAllowed</code></td><td>The consumer is rejected by the producer’s <code>accept_if</code> predicate</td></tr>
<tr><td><code>10_509</code></td><td><code>NoCapacity</code></td><td>The producer has reached <code>max_consumers</code></td></tr>
<tr><td><code>10_413</code></td><td><code>TooSlow</code></td><td>The consumer was disconnected for lagging behind</td></tr>
</tbody>
</table>
</div>
<h2 id="subsystem-configuration"><a class="header" href="#subsystem-configuration">Subsystem Configuration</a></h2>
<p>The <code>Streams</code> config currently has one setting:</p>
<pre><code class="language-rust ignore">Config::builder()
    .with_backoff(ExponentialBackoffBuilder::default()
        .with_max_elapsed_time(Some(Duration::from_secs(300)))
        .build())
    .build()?;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>backoff</code></td><td>Exponential (max 5 min)</td><td>Default backoff policy for consumer connection retries</td></tr>
</tbody>
</table>
</div>
<p>Individual producers and consumers can override this via their respective builders.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="producers"><a class="header" href="#producers">Producers</a></h1>
<p>A <code>Producer&lt;D&gt;</code> is a handle for sending data of type <code>D</code> to all connected consumers. Multiple <code>Producer</code> handles can exist for the same stream (mpsc pattern) — they share the same underlying fanout sink.</p>
<h2 id="creating-producers"><a class="header" href="#creating-producers">Creating Producers</a></h2>
<p><strong>Simple (default configuration):</strong></p>
<pre><code class="language-rust ignore">let producer = network.streams().produce::&lt;MyDatum&gt;();</code></pre>
<p>If a producer for this datum type already exists, the existing one is returned.</p>
<p><strong>With builder (advanced configuration):</strong></p>
<pre><code class="language-rust ignore">let producer = network.streams()
    .producer::&lt;MyDatum&gt;()
    .accept_if(|peer| peer.tags().contains(&amp;"trusted".into()))
    .online_when(|c| c.minimum_of(2).with_tags("validator"))
    .disconnect_lagging(true)
    .with_buffer_size(2048)
    .with_max_consumers(10)
    .with_stream_id("custom-id")
    .build()?;</code></pre>
<h2 id="builder-options-1"><a class="header" href="#builder-options-1">Builder Options</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>accept_if(predicate)</code></td><td>Accept all</td><td>Predicate to accept/reject incoming consumer connections</td></tr>
<tr><td><code>online_when(conditions)</code></td><td><code>minimum_of(1)</code></td><td>Conditions under which the producer is online</td></tr>
<tr><td><code>disconnect_lagging(bool)</code></td><td><code>true</code></td><td>Disconnect consumers that fall behind <code>buffer_size</code></td></tr>
<tr><td><code>with_buffer_size(n)</code></td><td><code>1024</code></td><td>Internal channel buffer size</td></tr>
<tr><td><code>with_max_consumers(n)</code></td><td><code>usize::MAX</code></td><td>Maximum allowed simultaneous consumers</td></tr>
<tr><td><code>with_stream_id(id)</code></td><td><code>D::derived_stream_id()</code></td><td>Custom stream identity</td></tr>
<tr><td><code>with_undelivered_sink(sender)</code></td><td>None</td><td>Capture datum that no consumer matched</td></tr>
</tbody>
</table>
</div>
<h2 id="sending-data"><a class="header" href="#sending-data">Sending Data</a></h2>
<h3 id="via-sink-trait"><a class="header" href="#via-sink-trait">Via <code>Sink</code> Trait</a></h3>
<p><code>Producer&lt;D&gt;</code> implements <code>futures::Sink&lt;D&gt;</code>. The <code>send()</code> method waits for the producer to be online before accepting data:</p>
<pre><code class="language-rust ignore">use futures::SinkExt;

// Blocks until at least one consumer is connected (default online condition)
producer.send(datum).await?;</code></pre>
<p>If the producer is offline, <code>poll_ready</code> will not resolve until the online conditions are met.</p>
<h3 id="via-try_send"><a class="header" href="#via-try_send">Via <code>try_send</code></a></h3>
<p>For non-blocking sends:</p>
<pre><code class="language-rust ignore">match producer.try_send(datum) {
    Ok(()) =&gt; { /* sent to fanout */ }
    Err(Error::Offline(d)) =&gt; { /* no consumers, datum returned */ }
    Err(Error::Full(d)) =&gt; { /* buffer full, datum returned */ }
    Err(Error::Closed(d)) =&gt; { /* producer closed */ }
}</code></pre>
<p>All error variants return the unsent datum so you can retry or inspect it.</p>
<h2 id="online-conditions"><a class="header" href="#online-conditions">Online Conditions</a></h2>
<p>By default, a producer is online when it has at least one connected consumer. Customize this:</p>
<pre><code class="language-rust ignore">// Online when at least 3 validators are subscribed
let producer = network.streams()
    .producer::&lt;MyDatum&gt;()
    .online_when(|c| c.minimum_of(3).with_tags("validator"))
    .build()?;</code></pre>
<p>Check online status at any time:</p>
<pre><code class="language-rust ignore">if producer.is_online() {
    producer.try_send(datum)?;
}</code></pre>
<h2 id="observing-status"><a class="header" href="#observing-status">Observing Status</a></h2>
<p>The <code>when()</code> API provides reactive status monitoring:</p>
<pre><code class="language-rust ignore">// Wait until online
producer.when().online().await;

// Wait until offline
producer.when().offline().await;

// Wait until subscribed by at least one peer
producer.when().subscribed().await;

// Wait until subscribed by at least N peers
producer.when().subscribed().minimum_of(3).await;

// Wait until subscribed by peers with specific tags
producer.when().subscribed().with_tags("validator").await;

// Wait until no subscribers
producer.when().unsubscribed().await;</code></pre>
<h2 id="inspecting-consumers"><a class="header" href="#inspecting-consumers">Inspecting Consumers</a></h2>
<p>Iterate over the currently connected consumers:</p>
<pre><code class="language-rust ignore">for info in producer.consumers() {
    println!(
        "Consumer {} connected to stream {} — state: {:?}, stats: {}",
        info.consumer_id(),
        info.stream_id(),
        info.state(),
        info.stats(),
    );
}</code></pre>
<p>Each <code>ChannelInfo</code> provides access to:</p>
<ul>
<li><code>stream_id()</code> — the stream this subscription is for</li>
<li><code>producer_id()</code> / <code>consumer_id()</code> — the peer IDs</li>
<li><code>peer()</code> — the <code>PeerEntry</code> snapshot at subscription time</li>
<li><code>state()</code> — <code>Connecting</code>, <code>Connected</code>, or <code>Terminated</code></li>
<li><code>state_watcher()</code> — a <code>watch::Receiver&lt;State&gt;</code> for monitoring changes</li>
<li><code>stats()</code> — <code>Stats</code> with <code>datums()</code>, <code>bytes()</code>, <code>uptime()</code></li>
<li><code>is_connected()</code> — shorthand for <code>state() == Connected</code></li>
<li><code>disconnected()</code> — future that resolves when terminated</li>
</ul>
<h2 id="undelivered-sink"><a class="header" href="#undelivered-sink">Undelivered Sink</a></h2>
<p>Capture datum that did not match any consumer’s criteria:</p>
<pre><code class="language-rust ignore">let (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();

let producer = network.streams()
    .producer::&lt;MyDatum&gt;()
    .with_undelivered_sink(tx)
    .build()?;

// In another task
while let Some(datum) = rx.recv().await {
    tracing::warn!("Datum had no matching consumer: {:?}", datum);
}</code></pre>
<blockquote>
<p><strong>Note:</strong> In default configuration (online when ≥ 1 subscriber), undelivered events only occur if connected consumers’ criteria reject the datum. If you customize <code>online_when</code> to allow publishing with zero subscribers, the sink captures all datum sent while nobody is listening.</p>
</blockquote>
<h2 id="builder-errors"><a class="header" href="#builder-errors">Builder Errors</a></h2>
<p><code>build()</code> returns <code>Err(BuilderError::AlreadyExists(existing))</code> if a producer for the stream ID already exists. The error contains the existing <code>Producer&lt;D&gt;</code> handle so you can use it directly:</p>
<pre><code class="language-rust ignore">match network.streams().producer::&lt;MyDatum&gt;().build() {
    Ok(new) =&gt; new,
    Err(BuilderError::AlreadyExists(existing)) =&gt; existing,
}</code></pre>
<p>The simple <code>produce()</code> method handles this automatically — returning the existing producer if one exists.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="consumers"><a class="header" href="#consumers">Consumers</a></h1>
<p>A <code>Consumer&lt;D&gt;</code> receives data of type <code>D</code> from remote producers. Each consumer has its own worker task that discovers producers, manages subscriptions, and delivers data.</p>
<h2 id="creating-consumers"><a class="header" href="#creating-consumers">Creating Consumers</a></h2>
<p><strong>Simple (default configuration):</strong></p>
<pre><code class="language-rust ignore">let mut consumer = network.streams().consume::&lt;MyDatum&gt;();</code></pre>
<p><strong>With builder (advanced configuration):</strong></p>
<pre><code class="language-rust ignore">let mut consumer = network.streams()
    .consumer::&lt;MyDatum&gt;()
    .subscribe_if(|peer| peer.tags().contains(&amp;"primary".into()))
    .with_criteria(Criteria::default())
    .with_stream_id("custom-id")
    .with_backoff(ExponentialBackoffBuilder::default()
        .with_max_elapsed_time(Some(Duration::from_secs(60)))
        .build())
    .build();</code></pre>
<h2 id="builder-options-2"><a class="header" href="#builder-options-2">Builder Options</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>subscribe_if(predicate)</code></td><td>Accept all</td><td>Filter which producers to subscribe to</td></tr>
<tr><td><code>with_criteria(criteria)</code></td><td><code>Criteria::default()</code></td><td>Data selection criteria sent to producers</td></tr>
<tr><td><code>with_stream_id(id)</code></td><td><code>D::derived_stream_id()</code></td><td>Custom stream identity</td></tr>
<tr><td><code>with_backoff(policy)</code></td><td>From <code>Streams</code> config</td><td>Backoff policy for reconnection retries</td></tr>
</tbody>
</table>
</div>
<h2 id="receiving-data"><a class="header" href="#receiving-data">Receiving Data</a></h2>
<h3 id="via-recv"><a class="header" href="#via-recv">Via <code>recv()</code></a></h3>
<p>The primary receiving method — async, blocks until data is available:</p>
<pre><code class="language-rust ignore">while let Some(datum) = consumer.recv().await {
    process(datum);
}
// Returns None when the consumer is closed</code></pre>
<h3 id="via-try_recv"><a class="header" href="#via-try_recv">Via <code>try_recv()</code></a></h3>
<p>Non-blocking receive for polling patterns:</p>
<pre><code class="language-rust ignore">match consumer.try_recv() {
    Ok(datum) =&gt; process(datum),
    Err(TryRecvError::Empty) =&gt; { /* no data available */ }
    Err(TryRecvError::Disconnected) =&gt; { /* consumer closed */ }
}</code></pre>
<h3 id="via-stream-trait"><a class="header" href="#via-stream-trait">Via <code>Stream</code> Trait</a></h3>
<p><code>Consumer&lt;D&gt;</code> implements <code>futures::Stream&lt;Item = D&gt;</code>:</p>
<pre><code class="language-rust ignore">use futures::StreamExt;

while let Some(datum) = consumer.next().await {
    process(datum);
}

// Or with combinators
let filtered = consumer
    .filter(|d| futures::future::ready(d.price &gt; 100.0))
    .take(10)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .await;</code></pre>
<h2 id="producer-selection"><a class="header" href="#producer-selection">Producer Selection</a></h2>
<p>By default, a consumer subscribes to <strong>every</strong> discovered producer of the same stream ID. Use <code>subscribe_if</code> to be selective:</p>
<pre><code class="language-rust ignore">// Only subscribe to producers tagged as "primary"
let consumer = network.streams()
    .consumer::&lt;PriceUpdate&gt;()
    .subscribe_if(|peer| peer.tags().contains(&amp;"primary".into()))
    .build();</code></pre>
<p>The predicate receives a <code>&amp;PeerEntry</code> and is evaluated each time a new producer is discovered.</p>
<h2 id="criteria"><a class="header" href="#criteria">Criteria</a></h2>
<p><code>Criteria</code> are sent to the producer when subscribing. They allow content-based filtering at the source. Currently <code>Criteria</code> is a placeholder that matches everything:</p>
<pre><code class="language-rust ignore">pub struct Criteria {}

impl Criteria {
    pub const fn matches&lt;D: Datum&gt;(&amp;self, _item: &amp;D) -&gt; bool {
        true
    }
}</code></pre>
<h2 id="backoff--reconnection"><a class="header" href="#backoff--reconnection">Backoff &amp; Reconnection</a></h2>
<p>When a connection to a producer fails, the consumer retries with an exponential backoff policy.</p>
<p><strong>Global default</strong> (from <code>Streams</code> config): exponential backoff up to 5 minutes.</p>
<p><strong>Per-consumer override:</strong></p>
<pre><code class="language-rust ignore">use backoff::ExponentialBackoffBuilder;

let consumer = network.streams()
    .consumer::&lt;MyDatum&gt;()
    .with_backoff(ExponentialBackoffBuilder::default()
        .with_max_elapsed_time(Some(Duration::from_secs(30)))
        .build())
    .build();</code></pre>
<h2 id="observing-status-1"><a class="header" href="#observing-status-1">Observing Status</a></h2>
<p>The <code>when()</code> API mirrors the producer side:</p>
<pre><code class="language-rust ignore">// Wait until connected to at least one producer
consumer.when().online().await;

// Wait until connected to at least one producer
consumer.when().subscribed().await;

// Wait until connected to at least N producers
consumer.when().subscribed().to_at_least(3).await;

// Wait until no producers are connected
consumer.when().unsubscribed().await;</code></pre>
<p>Check online status imperatively:</p>
<pre><code class="language-rust ignore">if consumer.is_online() {
    // consumer has active connections
}</code></pre>
<h2 id="statistics"><a class="header" href="#statistics">Statistics</a></h2>
<p>Each consumer tracks aggregated stats:</p>
<pre><code class="language-rust ignore">let stats = consumer.stats();
println!("Received {} datums ({} bytes)", stats.datums(), stats.bytes());

if let Some(uptime) = stats.uptime() {
    println!("Connected for {:?}", uptime);
}</code></pre>
<p><code>Stats</code> provides:</p>
<ul>
<li><code>datums()</code> — total number of datums received</li>
<li><code>bytes()</code> — total serialized bytes received</li>
<li><code>uptime()</code> — <code>Option&lt;Duration&gt;</code> since last connection (None if currently disconnected)</li>
</ul>
<h2 id="inspecting-producers"><a class="header" href="#inspecting-producers">Inspecting Producers</a></h2>
<pre><code class="language-rust ignore">for info in consumer.producers() {
    println!(
        "Connected to producer {} — {:?}, {}",
        info.producer_id(),
        info.state(),
        info.stats(),
    );
}</code></pre>
<p>Each <code>ChannelInfo</code> provides the same API as on the <a href="#inspecting-consumers">producer side</a>.</p>
<h2 id="multiple-consumers"><a class="header" href="#multiple-consumers">Multiple Consumers</a></h2>
<p>Multiple consumers can be created for the same stream. Each gets its own independent copy of the data:</p>
<pre><code class="language-rust ignore">let mut consumer_a = network.streams().consume::&lt;PriceUpdate&gt;();
let mut consumer_b = network.streams().consume::&lt;PriceUpdate&gt;();

// Both receive all PriceUpdate data independently</code></pre>
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<p>When a <code>Consumer</code> handle is dropped, its background worker task is cancelled (via a <code>DropGuard</code>) and all connections to producers are closed. No explicit shutdown is needed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="status--conditions"><a class="header" href="#status--conditions">Status &amp; Conditions</a></h1>
<p>Both producers and consumers expose a reactive status API through <code>When</code> and <code>ChannelConditions</code>. This allows you to write event-driven code that reacts to changes in subscription state.</p>
<h2 id="the-when-api"><a class="header" href="#the-when-api">The <code>When</code> API</a></h2>
<p>Every <code>Producer</code> and <code>Consumer</code> provides a <code>when()</code> method that returns a <code>&amp;When</code> handle:</p>
<pre><code class="language-rust ignore">let producer = network.streams().produce::&lt;MyDatum&gt;();
let when = producer.when();</code></pre>
<h3 id="online--offline"><a class="header" href="#online--offline">Online / Offline</a></h3>
<pre><code class="language-rust ignore">// Resolves when the channel is ready (all publishing conditions met)
when.online().await;

// Resolves when the channel goes offline
when.offline().await;

// Check immediately
if when.is_online() { /* ... */ }</code></pre>
<p>For producers, “online” means the <code>online_when</code> conditions are met (default: at least 1 consumer). For consumers, “online” means at least one producer connection is active.</p>
<h3 id="subscribed--unsubscribed"><a class="header" href="#subscribed--unsubscribed">Subscribed / Unsubscribed</a></h3>
<pre><code class="language-rust ignore">// Resolves when at least one peer is connected
when.subscribed().await;

// Resolves when zero peers are connected
when.unsubscribed().await;</code></pre>
<h2 id="channelconditions"><a class="header" href="#channelconditions">ChannelConditions</a></h2>
<p><code>when().subscribed()</code> returns a <code>ChannelConditions</code> — a composable future that resolves when the subscription state matches your criteria.</p>
<h3 id="minimum-peers"><a class="header" href="#minimum-peers">Minimum Peers</a></h3>
<pre><code class="language-rust ignore">// Wait for at least 3 connected peers
when.subscribed().minimum_of(3).await;</code></pre>
<h3 id="tag-filtering"><a class="header" href="#tag-filtering">Tag Filtering</a></h3>
<pre><code class="language-rust ignore">// Wait for peers that have the "validator" tag
when.subscribed().with_tags("validator").await;

// Multiple tags (all must be present on the peer)
when.subscribed().with_tags(["validator", "us-east"]).await;</code></pre>
<h3 id="custom-predicates"><a class="header" href="#custom-predicates">Custom Predicates</a></h3>
<pre><code class="language-rust ignore">// Wait for a peer matching an arbitrary condition
when.subscribed()
    .with_predicate(|peer: &amp;PeerEntry| peer.tags().len() &gt;= 3)
    .await;</code></pre>
<h3 id="combining-conditions"><a class="header" href="#combining-conditions">Combining Conditions</a></h3>
<p>Conditions compose naturally:</p>
<pre><code class="language-rust ignore">// At least 2 validators from the us-east region
when.subscribed()
    .minimum_of(2)
    .with_tags("validator")
    .with_predicate(|p| p.tags().contains(&amp;"us-east".into()))
    .await;</code></pre>
<h3 id="inverse-conditions"><a class="header" href="#inverse-conditions">Inverse Conditions</a></h3>
<p>Use <code>unmet()</code> to invert a condition:</p>
<pre><code class="language-rust ignore">// Wait until there are fewer than 3 validators
when.subscribed()
    .minimum_of(3)
    .with_tags("validator")
    .unmet()
    .await;</code></pre>
<h3 id="re-triggering"><a class="header" href="#re-triggering">Re-Triggering</a></h3>
<p><code>ChannelConditions</code> implements <code>Future</code> and can be polled repeatedly. After resolving, it resets and will resolve again when the condition transitions from <strong>not met → met</strong>. This makes it suitable for use in loops:</p>
<pre><code class="language-rust ignore">let mut condition = when.subscribed().minimum_of(2);
loop {
    (&amp;mut condition).await;
    println!("We now have 2+ subscribers again!");
}</code></pre>
<h3 id="checking-immediately"><a class="header" href="#checking-immediately">Checking Immediately</a></h3>
<pre><code class="language-rust ignore">let condition = when.subscribed().minimum_of(3);
if condition.is_condition_met() {
    // There are currently 3+ matching peers
}</code></pre>
<p><code>ChannelConditions</code> also supports comparison with <code>bool</code>:</p>
<pre><code class="language-rust ignore">if when.subscribed().minimum_of(3) == true {
    // equivalent to is_condition_met()
}</code></pre>
<h2 id="channelinfo"><a class="header" href="#channelinfo">ChannelInfo</a></h2>
<p><code>ChannelInfo</code> represents an individual connection between a consumer and a producer:</p>
<pre><code class="language-rust ignore">pub struct ChannelInfo {
    stream_id: StreamId,
    criteria: Criteria,
    producer_id: PeerId,
    consumer_id: PeerId,
    stats: Arc&lt;Stats&gt;,
    peer: Arc&lt;PeerEntry&gt;,
    state: watch::Receiver&lt;State&gt;,
}</code></pre>
<h3 id="connection-state"><a class="header" href="#connection-state">Connection State</a></h3>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum State {
    Connecting,   // Handshake in progress
    Connected,    // Active subscription
    Terminated,   // Unrecoverably closed
}</code></pre>
<p>Monitor state changes:</p>
<pre><code class="language-rust ignore">let info: ChannelInfo = /* from producers() or consumers() */;

// Check current state
match info.state() {
    State::Connected =&gt; { /* active */ }
    State::Connecting =&gt; { /* handshake in progress */ }
    State::Terminated =&gt; { /* closed */ }
}

// Watch for state transitions
let mut watcher = info.state_watcher().clone();
while watcher.changed().await.is_ok() {
    println!("State changed to: {:?}", *watcher.borrow());
}

// Wait for disconnection
info.disconnected().await;</code></pre>
<h2 id="stats"><a class="header" href="#stats">Stats</a></h2>
<p>Every channel tracks real-time statistics:</p>
<pre><code class="language-rust ignore">let stats = info.stats();

println!("Datums: {}", stats.datums());   // Total datums transferred
println!("Bytes: {}", stats.bytes());     // Total bytes transferred
println!("Uptime: {:?}", stats.uptime()); // Option&lt;Duration&gt; since connection

// Display formatting included
println!("{}", stats);
// Output: "uptime: 2m 30s, datums: 15432, bytes: 1.23 MB"</code></pre>
<p><code>Stats</code> implements <code>Display</code> with human-readable formatting using <code>humansize</code> and <code>humantime</code>.</p>
<h2 id="using-status-for-online-conditions"><a class="header" href="#using-status-for-online-conditions">Using Status for Online Conditions</a></h2>
<p>The <code>ChannelConditions</code> type is also used to configure producer online conditions via the builder:</p>
<pre><code class="language-rust ignore">let producer = network.streams()
    .producer::&lt;MyDatum&gt;()
    .online_when(|c| c.minimum_of(2).with_tags("validator"))
    .build()?;</code></pre>
<p>The closure receives a <code>ChannelConditions</code> and returns it with your conditions applied. This is evaluated every time the subscription set changes.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="groups-1"><a class="header" href="#groups-1">Groups</a></h1>
<p>Availability Groups are clusters of trusted nodes on the same mosaik network that coordinate with each other for load balancing and failover. Members of a group share a secret key, maintain a consistent replicated state through a modified Raft consensus protocol, and stay connected via an all-to-all mesh of persistent <strong>bonds</strong>.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<pre><code>          ┌──────────┐
          │  Node A   │
          │ (Leader)  │
          └────┬──┬───┘
          bond/  \bond
              /    \
 ┌──────────┐      ┌──────────┐
 │  Node B   │─bond─│  Node C   │
 │(Follower) │      │(Follower) │
 └───────────┘      └───────────┘
</code></pre>
<p>Every pair of group members maintains a persistent <strong>bond</strong> — an authenticated, bidirectional QUIC connection. Bonds carry Raft consensus messages, heartbeats, and log-sync traffic.</p>
<h2 id="trust-model"><a class="header" href="#trust-model">Trust Model</a></h2>
<p>Groups are <strong>not</strong> Byzantine fault tolerant. All members within a group are assumed to be honest and operated by the same entity. The <code>GroupKey</code> acts as the sole admission control — only nodes that know the key can join.</p>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre><code class="language-rust ignore">use mosaik::groups::GroupKey;

// All group members must use the same key
let key = GroupKey::generate();

// Join with default settings (NoOp state machine)
let group = network.groups().with_key(key).join();

// Wait for leader election
let leader = group.when().leader_elected().await;
println!("Leader: {leader}");

// Check local role
if group.is_leader() {
    println!("I am the leader");
}</code></pre>
<h2 id="group-identity"><a class="header" href="#group-identity">Group Identity</a></h2>
<p>A <code>GroupId</code> is derived from three components:</p>
<ol>
<li><strong>Group key</strong> — the shared secret (<code>GroupKey</code>)</li>
<li><strong>Consensus configuration</strong> — election timeouts, heartbeat intervals, etc.</li>
<li><strong>State machine signature</strong> — the state machine’s <code>signature()</code> + state sync <code>signature()</code></li>
</ol>
<p>Any divergence in these values across nodes produces a different <code>GroupId</code>, preventing misconfigured nodes from bonding.</p>
<pre><code class="language-rust ignore">// GroupId derivation (internal)
let id = key.secret().hashed()
    .derive(consensus.digest())
    .derive(state_machine.signature())
    .derive(state_machine.state_sync().signature());</code></pre>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Groups</code></td><td>Public API gateway — one per <code>Network</code></td></tr>
<tr><td><code>GroupBuilder</code></td><td>Typestate builder for configuring and joining a group</td></tr>
<tr><td><code>Group&lt;M&gt;</code></td><td>Handle for interacting with a joined group</td></tr>
<tr><td><code>GroupKey</code></td><td>Shared secret for admission control</td></tr>
<tr><td><code>GroupId</code></td><td>Unique identifier (<code>Digest</code>) derived from key + config + machine</td></tr>
<tr><td><code>Bond</code> / <code>Bonds</code></td><td>Persistent connections between group members</td></tr>
<tr><td><code>When</code></td><td>Reactive status API for group state changes</td></tr>
<tr><td><code>ConsensusConfig</code></td><td>Raft timing parameters</td></tr>
</tbody>
</table>
</div>
<h2 id="alpn-protocol"><a class="header" href="#alpn-protocol">ALPN Protocol</a></h2>
<p>Groups use <code>/mosaik/groups/1</code> as their ALPN identifier.</p>
<h2 id="close-reason-codes-1"><a class="header" href="#close-reason-codes-1">Close Reason Codes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Name</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>30_400</code></td><td><code>InvalidHandshake</code></td><td>Error during handshake decoding</td></tr>
<tr><td><code>30_404</code></td><td><code>GroupNotFound</code></td><td>Group ID not known to acceptor</td></tr>
<tr><td><code>30_405</code></td><td><code>InvalidProof</code></td><td>Authentication proof invalid</td></tr>
<tr><td><code>30_408</code></td><td><code>Timeout</code></td><td>Timed out waiting for response</td></tr>
<tr><td><code>30_429</code></td><td><code>AlreadyBonded</code></td><td>A bond already exists between these peers</td></tr>
</tbody>
</table>
</div>
<h2 id="subsystem-configuration-1"><a class="header" href="#subsystem-configuration-1">Subsystem Configuration</a></h2>
<pre><code class="language-rust ignore">use mosaik::groups::Config;

let config = Config::builder()
    .with_handshake_timeout(Duration::from_secs(2))  // default
    .build()?;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>handshake_timeout</code></td><td>2 seconds</td><td>Timeout for bond handshake completion</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="joining-groups"><a class="header" href="#joining-groups">Joining Groups</a></h1>
<p>The <code>GroupBuilder</code> uses a <strong>typestate pattern</strong> to ensure groups are configured correctly at compile time. You cannot call <code>join()</code> until both storage and state machine are set (or you use the shorthand <code>join()</code> which defaults to <code>NoOp</code>).</p>
<h2 id="builder-flow"><a class="header" href="#builder-flow">Builder Flow</a></h2>
<pre><code>groups.with_key(key)
  ├── .join()                          // NoOp machine, InMemoryLogStore
  └── .with_state_machine(machine)
        ├── .join()                    // InMemoryLogStore (default)
        ├── .with_consensus_config(c)
        │     └── .join()
        └── .with_log_storage(store)
              └── .join()
</code></pre>
<h2 id="minimal-join-noop"><a class="header" href="#minimal-join-noop">Minimal Join (NoOp)</a></h2>
<p>Useful for leader election without application logic:</p>
<pre><code class="language-rust ignore">let group = network.groups().with_key(key).join();</code></pre>
<p>This creates a group with:</p>
<ul>
<li><code>NoOp</code> state machine (commands are <code>()</code>, queries are <code>()</code>)</li>
<li><code>InMemoryLogStore</code> for storage</li>
<li>Default <code>ConsensusConfig</code></li>
</ul>
<h2 id="with-custom-state-machine"><a class="header" href="#with-custom-state-machine">With Custom State Machine</a></h2>
<pre><code class="language-rust ignore">let group = network.groups()
    .with_key(key)
    .with_state_machine(MyStateMachine::new())
    .join();</code></pre>
<p>The state machine must be set <strong>before</strong> storage, since the storage type depends on the command type.</p>
<h2 id="with-custom-storage"><a class="header" href="#with-custom-storage">With Custom Storage</a></h2>
<pre><code class="language-rust ignore">let group = network.groups()
    .with_key(key)
    .with_state_machine(MyStateMachine::new())
    .with_log_storage(MyDurableStore::new())
    .join();</code></pre>
<p>Storage must implement <code>Storage&lt;M::Command&gt;</code>.</p>
<h2 id="groupkey"><a class="header" href="#groupkey">GroupKey</a></h2>
<p>A <code>GroupKey</code> is the shared secret that all members must possess:</p>
<pre><code class="language-rust ignore">use mosaik::groups::GroupKey;

// Generate a new random key
let key = GroupKey::generate();

// All members use the same key
// The key can be serialized and distributed securely</code></pre>
<h2 id="consensusconfig"><a class="header" href="#consensusconfig">ConsensusConfig</a></h2>
<p>All consensus parameters are part of <code>GroupId</code> derivation — every member must use the same values.</p>
<pre><code class="language-rust ignore">use mosaik::groups::ConsensusConfig;

let config = ConsensusConfig::builder()
    .with_heartbeat_interval(Duration::from_millis(500))     // default
    .with_heartbeat_jitter(Duration::from_millis(150))       // default
    .with_max_missed_heartbeats(10)                          // default
    .with_election_timeout(Duration::from_secs(2))           // default
    .with_election_timeout_jitter(Duration::from_millis(500))// default
    .with_bootstrap_delay(Duration::from_secs(3))            // default
    .with_forward_timeout(Duration::from_secs(2))            // default
    .with_query_timeout(Duration::from_secs(2))              // default
    .build()?;

let group = network.groups()
    .with_key(key)
    .with_state_machine(machine)
    .with_consensus_config(config)
    .join();</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>heartbeat_interval</code></td><td>500ms</td><td>Interval between bond heartbeat pings</td></tr>
<tr><td><code>heartbeat_jitter</code></td><td>150ms</td><td>Max random jitter subtracted from heartbeat interval</td></tr>
<tr><td><code>max_missed_heartbeats</code></td><td>10</td><td>Missed heartbeats before bond is considered dead</td></tr>
<tr><td><code>election_timeout</code></td><td>2s</td><td>Base timeout before a follower starts an election</td></tr>
<tr><td><code>election_timeout_jitter</code></td><td>500ms</td><td>Max random jitter added to election timeout</td></tr>
<tr><td><code>bootstrap_delay</code></td><td>3s</td><td>Wait time before first election to allow peer discovery</td></tr>
<tr><td><code>forward_timeout</code></td><td>2s</td><td>Timeout for forwarding commands to the leader</td></tr>
<tr><td><code>query_timeout</code></td><td>2s</td><td>Timeout for strong-consistency query responses</td></tr>
</tbody>
</table>
</div>
<h3 id="leadership-preference"><a class="header" href="#leadership-preference">Leadership Preference</a></h3>
<p>Nodes can deprioritize leadership to prefer being followers:</p>
<pre><code class="language-rust ignore">// 3x longer election timeout (default multiplier)
let config = ConsensusConfig::default().deprioritize_leadership();

// Custom multiplier
let config = ConsensusConfig::default().deprioritize_leadership_by(5);</code></pre>
<p>This multiplies both <code>election_timeout</code> and <code>bootstrap_delay</code>, reducing the chance of becoming leader.</p>
<h2 id="idempotent-joins"><a class="header" href="#idempotent-joins">Idempotent Joins</a></h2>
<p>If you <code>join()</code> a group whose <code>GroupId</code> already exists on this node, the existing <code>Group</code> handle is returned. No duplicate worker is spawned.</p>
<h2 id="lifecycle-1"><a class="header" href="#lifecycle-1">Lifecycle</a></h2>
<p>When a <code>Group&lt;M&gt;</code> handle is dropped:</p>
<ol>
<li>Bonds notify peers of the departure</li>
<li>The group’s cancellation token is triggered</li>
<li>The group is removed from the active groups map</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="state-machines"><a class="header" href="#state-machines">State Machines</a></h1>
<p>Every group runs a replicated state machine (RSM) that processes commands and answers queries. The <code>StateMachine</code> trait is the primary extension point for application logic.</p>
<h2 id="the-statemachine-trait"><a class="header" href="#the-statemachine-trait">The StateMachine Trait</a></h2>
<pre><code class="language-rust ignore">pub trait StateMachine: Sized + Send + 'static {
    type Command: Command;       // Mutating operations
    type Query: Query;           // Read-only operations
    type QueryResult: QueryResult; // Query responses
    type StateSync: StateSync&lt;Machine = Self&gt;; // Catch-up strategy

    fn signature(&amp;self) -&gt; UniqueId;
    fn apply(&amp;mut self, command: Self::Command, ctx: &amp;dyn ApplyContext);
    fn query(&amp;self, query: Self::Query) -&gt; Self::QueryResult;
    fn state_sync(&amp;self) -&gt; Self::StateSync;

    // Optional overrides
    fn apply_batch(&amp;mut self, commands: impl IntoIterator&lt;Item = Self::Command&gt;, ctx: &amp;dyn ApplyContext) { ... }
    fn consensus_config(&amp;self) -&gt; Option&lt;ConsensusConfig&gt; { None }
}</code></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Bound</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Command</code></td><td><code>Clone + Send + Serialize + DeserializeOwned + 'static</code></td><td>State-mutating operations replicated via Raft log</td></tr>
<tr><td><code>Query</code></td><td><code>Clone + Send + Serialize + DeserializeOwned + 'static</code></td><td>Read-only operations, not replicated</td></tr>
<tr><td><code>QueryResult</code></td><td><code>Clone + Send + Serialize + DeserializeOwned + 'static</code></td><td>Responses to queries</td></tr>
<tr><td><code>StateSync</code></td><td><code>StateSync&lt;Machine = Self&gt;</code></td><td>How lagging followers catch up</td></tr>
</tbody>
</table>
</div>
<p>All message types get blanket implementations from <code>StateMachineMessage</code>, so any <code>Clone + Send + Serialize + DeserializeOwned + 'static</code> type qualifies.</p>
<h2 id="implementing-a-state-machine"><a class="header" href="#implementing-a-state-machine">Implementing a State Machine</a></h2>
<p>Here is a complete counter example:</p>
<pre><code class="language-rust ignore">use mosaik::groups::*;
use serde::{Serialize, Deserialize};

#[derive(Default)]
struct Counter {
    value: i64,
}

#[derive(Clone, Serialize, Deserialize)]
enum CounterCmd {
    Increment(i64),
    Decrement(i64),
    Reset,
}

#[derive(Clone, Serialize, Deserialize)]
enum CounterQuery {
    Value,
}

impl StateMachine for Counter {
    type Command = CounterCmd;
    type Query = CounterQuery;
    type QueryResult = i64;
    type StateSync = LogReplaySync&lt;Self&gt;;

    fn signature(&amp;self) -&gt; UniqueId {
        UniqueId::from("counter_v1")
    }

    fn apply(&amp;mut self, command: CounterCmd, _ctx: &amp;dyn ApplyContext) {
        match command {
            CounterCmd::Increment(n) =&gt; self.value += n,
            CounterCmd::Decrement(n) =&gt; self.value -= n,
            CounterCmd::Reset =&gt; self.value = 0,
        }
    }

    fn query(&amp;self, query: CounterQuery) -&gt; i64 {
        match query {
            CounterQuery::Value =&gt; self.value,
        }
    }

    fn state_sync(&amp;self) -&gt; LogReplaySync&lt;Self&gt; {
        LogReplaySync::default()
    }
}</code></pre>
<h2 id="the-signature-method"><a class="header" href="#the-signature-method">The <code>signature()</code> Method</a></h2>
<p>Returns a <code>UniqueId</code> that is part of the <code>GroupId</code> derivation. <strong>All group members must return the same signature.</strong> Different signatures → different <code>GroupId</code> → nodes cannot bond.</p>
<p>Use it to version your state machine:</p>
<pre><code class="language-rust ignore">fn signature(&amp;self) -&gt; UniqueId {
    UniqueId::from("orderbook_matching_engine_v2")
}</code></pre>
<h2 id="applycontext"><a class="header" href="#applycontext">ApplyContext</a></h2>
<p>The <code>apply()</code> method receives a <code>&amp;dyn ApplyContext</code> providing deterministic metadata:</p>
<pre><code class="language-rust ignore">pub trait ApplyContext {
    fn committed(&amp;self) -&gt; Cursor;     // Last committed position before this batch
    fn log_position(&amp;self) -&gt; Cursor;  // Last log position
    fn current_term(&amp;self) -&gt; Term;    // Term of the commands being applied
}</code></pre>
<blockquote>
<p><strong>Important:</strong> The context is safe for deterministic state machines — it never exposes non-deterministic data that could diverge across nodes.</p>
</blockquote>
<h2 id="batch-apply"><a class="header" href="#batch-apply">Batch Apply</a></h2>
<p>For performance, override <code>apply_batch</code>:</p>
<pre><code class="language-rust ignore">fn apply_batch(
    &amp;mut self,
    commands: impl IntoIterator&lt;Item = Self::Command&gt;,
    ctx: &amp;dyn ApplyContext,
) {
    // Apply all commands in a single database transaction
    let tx = self.db.begin();
    for command in commands {
        self.apply_one(&amp;tx, command, ctx);
    }
    tx.commit();
}</code></pre>
<p>The default implementation simply calls <code>apply()</code> for each command sequentially.</p>
<h2 id="noop-state-machine"><a class="header" href="#noop-state-machine">NoOp State Machine</a></h2>
<p>For leader-election-only use cases, mosaik provides <code>NoOp</code>:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Default)]
pub struct NoOp;

impl StateMachine for NoOp {
    type Command = ();
    type Query = ();
    type QueryResult = ();
    type StateSync = LogReplaySync&lt;Self&gt;;
    // ...
}</code></pre>
<p>Usage:</p>
<pre><code class="language-rust ignore">let group = network.groups().with_key(key).join(); // implicitly uses NoOp</code></pre>
<h2 id="state-synchronization"><a class="header" href="#state-synchronization">State Synchronization</a></h2>
<p>The <code>state_sync()</code> method returns a <code>StateSync</code> implementation used when followers need to catch up. For most cases, use <code>LogReplaySync</code>:</p>
<pre><code class="language-rust ignore">fn state_sync(&amp;self) -&gt; LogReplaySync&lt;Self&gt; {
    LogReplaySync::default()
}</code></pre>
<p><code>LogReplaySync</code> replays committed log entries to bring the follower’s state machine up to date. For advanced use cases (e.g., snapshot-based sync), implement the <code>StateSync</code> trait directly.</p>
<p>See the <a href="subsystems/internals/state-sync.html">State Sync</a> deep dive for details.</p>
<h2 id="consensus-config-hints"><a class="header" href="#consensus-config-hints">Consensus Config Hints</a></h2>
<p>A state machine can provide a default <code>ConsensusConfig</code>:</p>
<pre><code class="language-rust ignore">fn consensus_config(&amp;self) -&gt; Option&lt;ConsensusConfig&gt; {
    Some(ConsensusConfig::default().deprioritize_leadership())
}</code></pre>
<p>This is used when the builder does not specify an explicit config. It can be overridden by <code>with_consensus_config()</code> on the builder.</p>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>Commands are persisted in a log via the <code>Storage</code> trait:</p>
<pre><code class="language-rust ignore">pub trait Storage&lt;C: Command&gt;: Send + 'static {
    fn append(&amp;mut self, command: C, term: Term) -&gt; Index;
    fn available(&amp;self) -&gt; RangeInclusive&lt;Index&gt;;
    fn get(&amp;self, index: Index) -&gt; Option&lt;(C, Term)&gt;;
    fn get_range(&amp;self, range: &amp;RangeInclusive&lt;Index&gt;) -&gt; Vec&lt;(Term, Index, C)&gt;;
    fn truncate(&amp;mut self, at: Index);
    fn last(&amp;self) -&gt; Cursor;
    fn term_at(&amp;self, index: Index) -&gt; Option&lt;Term&gt;;
    fn prune_prefix(&amp;mut self, up_to: Index);
    fn reset_to(&amp;mut self, cursor: Cursor);
}</code></pre>
<p><code>InMemoryLogStore&lt;C&gt;</code> is the default implementation. For durability, implement <code>Storage</code> with a persistent backend (disk, database, etc.).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="commands--queries"><a class="header" href="#commands--queries">Commands &amp; Queries</a></h1>
<p>Once you have a <code>Group&lt;M&gt;</code> handle, you interact with the replicated state machine through <strong>commands</strong> (writes) and <strong>queries</strong> (reads).</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Commands mutate state and are replicated to all group members through the Raft log. They are guaranteed to be applied in the same order on every node.</p>
<h3 id="execute--send-and-wait"><a class="header" href="#execute--send-and-wait"><code>execute</code> — Send and Wait</a></h3>
<p>Sends a command and waits for it to be committed (replicated to a quorum):</p>
<pre><code class="language-rust ignore">let index = group.execute(CounterCmd::Increment(5)).await?;
println!("Command committed at log index {index}");</code></pre>
<p>If the local node is:</p>
<ul>
<li><strong>Leader</strong>: replicates to followers, resolves when quorum acknowledges</li>
<li><strong>Follower</strong>: forwards to the leader, resolves when the leader commits</li>
</ul>
<h3 id="execute_many--batch-send-and-wait"><a class="header" href="#execute_many--batch-send-and-wait"><code>execute_many</code> — Batch Send and Wait</a></h3>
<p>Send multiple commands atomically:</p>
<pre><code class="language-rust ignore">let range = group.execute_many([
    CounterCmd::Increment(1),
    CounterCmd::Increment(2),
    CounterCmd::Increment(3),
]).await?;
println!("Commands committed at indices {range:?}");</code></pre>
<p>Returns an <code>IndexRange</code> (<code>RangeInclusive&lt;Index&gt;</code>) covering all committed entries.</p>
<h3 id="feed--fire-and-forget"><a class="header" href="#feed--fire-and-forget"><code>feed</code> — Fire and Forget</a></h3>
<p>Sends a command without waiting for commitment. Resolves once the leader acknowledges receipt and assigns a log index:</p>
<pre><code class="language-rust ignore">let index = group.feed(CounterCmd::Increment(10)).await?;
println!("Command assigned index {index}, not yet committed");</code></pre>
<h3 id="feed_many--batch-fire-and-forget"><a class="header" href="#feed_many--batch-fire-and-forget"><code>feed_many</code> — Batch Fire and Forget</a></h3>
<pre><code class="language-rust ignore">let range = group.feed_many([
    CounterCmd::Reset,
    CounterCmd::Increment(100),
]).await?;</code></pre>
<h3 id="waiting-for-commitment-after-feed"><a class="header" href="#waiting-for-commitment-after-feed">Waiting for Commitment After Feed</a></h3>
<p>Combine <code>feed</code> with the cursor watcher:</p>
<pre><code class="language-rust ignore">let range = group.feed_many(commands).await?;

// Wait until all commands are committed
group.when().committed().reaches(range.clone()).await;</code></pre>
<h3 id="command-errors"><a class="header" href="#command-errors">Command Errors</a></h3>
<pre><code class="language-rust ignore">pub enum CommandError&lt;M: StateMachine&gt; {
    Offline(Vec&lt;M::Command&gt;),  // Node is offline; commands returned
    NoCommands,                // Empty command list
    GroupTerminated,           // Group is shut down
}</code></pre>
<p>The <code>Offline</code> variant returns the unsent commands so they can be retried:</p>
<pre><code class="language-rust ignore">match group.execute(cmd).await {
    Ok(index) =&gt; println!("Committed at {index}"),
    Err(CommandError::Offline(cmds)) =&gt; {
        // Save for retry
        group.when().online().await;
        group.execute(cmds.into_iter().next().unwrap()).await?;
    }
    Err(CommandError::GroupTerminated) =&gt; {
        panic!("Group is gone");
    }
    Err(CommandError::NoCommands) =&gt; unreachable!(),
}</code></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>Queries are read-only operations against the state machine. They are <strong>not</strong> replicated in the log.</p>
<h3 id="weak-consistency"><a class="header" href="#weak-consistency">Weak Consistency</a></h3>
<p>Reads from the local node’s state machine. Fast but may return stale data:</p>
<pre><code class="language-rust ignore">let result = group.query(CounterQuery::Value, Consistency::Weak).await?;
println!("Local counter value: {} (at index {})", result.result, result.at_position);</code></pre>
<h3 id="strong-consistency"><a class="header" href="#strong-consistency">Strong Consistency</a></h3>
<p>Forwards the query to the current leader, guaranteeing linearizable reads:</p>
<pre><code class="language-rust ignore">let result = group.query(CounterQuery::Value, Consistency::Strong).await?;
println!("Leader counter value: {} (at index {})", *result, result.state_position());</code></pre>
<h3 id="committedqueryresult"><a class="header" href="#committedqueryresult">CommittedQueryResult</a></h3>
<p>Query results are wrapped in <code>CommittedQueryResult&lt;M&gt;</code>:</p>
<pre><code class="language-rust ignore">pub struct CommittedQueryResult&lt;M: StateMachine&gt; {
    pub result: M::QueryResult,    // The actual result
    pub at_position: Index,        // Log index at query time
}</code></pre>
<p>It implements <code>Deref</code> to <code>M::QueryResult</code>, so you can use it directly:</p>
<pre><code class="language-rust ignore">let result = group.query(CounterQuery::Value, Consistency::Weak).await?;

// Deref to the inner result
let value: i64 = *result;

// Or access explicitly
let position = result.state_position();
let inner = result.into(); // Consume and get M::QueryResult</code></pre>
<h3 id="query-errors"><a class="header" href="#query-errors">Query Errors</a></h3>
<pre><code class="language-rust ignore">pub enum QueryError&lt;M: StateMachine&gt; {
    Offline(M::Query),   // Node offline; query returned
    GroupTerminated,     // Group shut down
}</code></pre>
<h2 id="ordering-guarantee"><a class="header" href="#ordering-guarantee">Ordering Guarantee</a></h2>
<p>Consecutive calls to <code>execute</code>, <code>execute_many</code>, <code>feed</code>, or <code>feed_many</code> on the same <code>Group</code> handle are guaranteed to be processed in the order they were issued.</p>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="command-query-separation"><a class="header" href="#command-query-separation">Command-Query Separation</a></h3>
<pre><code class="language-rust ignore">// Write path: fire and forget for throughput
group.feed(OrderCmd::Place(order)).await?;

// Read path: weak consistency for speed
let book = group.query(OrderQuery::Snapshot, Consistency::Weak).await?;

// Read path: strong consistency for accuracy
let book = group.query(OrderQuery::Snapshot, Consistency::Strong).await?;</code></pre>
<h3 id="execute-and-verify"><a class="header" href="#execute-and-verify">Execute and Verify</a></h3>
<pre><code class="language-rust ignore">let index = group.execute(CounterCmd::Increment(1)).await?;
let result = group.query(CounterQuery::Value, Consistency::Weak).await?;
assert!(result.at_position &gt;= index);</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="group-status"><a class="header" href="#group-status">Group Status</a></h1>
<p>The <code>Group&lt;M&gt;</code> handle exposes a rich reactive API for monitoring group state: leadership, log progress, and online status.</p>
<h2 id="inspecting-current-state"><a class="header" href="#inspecting-current-state">Inspecting Current State</a></h2>
<pre><code class="language-rust ignore">// Current leader (if any)
let leader: Option&lt;PeerId&gt; = group.leader();

// Am I the leader?
let is_leader: bool = group.is_leader();

// Group identity
let group_id: &amp;GroupId = group.id();

// Current committed index
let committed: Index = group.committed();

// Current log position (may include uncommitted entries)
let cursor: Cursor = group.log_position();

// Active bonds (peer connections)
let bonds: Bonds = group.bonds();

// Group configuration
let config: &amp;GroupConfig = group.config();</code></pre>
<h2 id="the-when-api-1"><a class="header" href="#the-when-api-1">The <code>When</code> API</a></h2>
<p><code>group.when()</code> returns a <code>&amp;When</code> handle for awaiting state transitions.</p>
<h3 id="leadership-events"><a class="header" href="#leadership-events">Leadership Events</a></h3>
<pre><code class="language-rust ignore">// Wait for any leader to be elected
let leader: PeerId = group.when().leader_elected().await;

// Wait for a different leader (leader change)
let new_leader: PeerId = group.when().leader_changed().await;

// Wait until a specific peer becomes leader
group.when().leader_is(expected_peer_id).await;

// Wait until the local node becomes leader
group.when().is_leader().await;

// Wait until the local node becomes a follower
group.when().is_follower().await;</code></pre>
<h3 id="online--offline-1"><a class="header" href="#online--offline-1">Online / Offline</a></h3>
<p>A node is <strong>online</strong> when:</p>
<ul>
<li>It is the leader, or</li>
<li>It is a fully synced follower (not catching up, not in an election)</li>
</ul>
<pre><code class="language-rust ignore">// Wait until ready to process commands
group.when().online().await;

// Wait until the node goes offline
group.when().offline().await;</code></pre>
<h3 id="log-position-watchers"><a class="header" href="#log-position-watchers">Log Position Watchers</a></h3>
<p>The <code>CursorWatcher</code> type provides fine-grained observation of log progress:</p>
<h4 id="committed-index"><a class="header" href="#committed-index">Committed Index</a></h4>
<pre><code class="language-rust ignore">let committed = group.when().committed();

// Wait until a specific index is committed
committed.reaches(42).await;

// Wait for any forward progress
let new_pos = committed.advanced().await;

// Wait for any change (including backward, e.g., log truncation)
let new_pos = committed.changed().await;

// Wait for regression (rare — happens during partition healing)
let new_pos = committed.reverted().await;</code></pre>
<p>You can also pass an <code>IndexRange</code> from <code>execute_many</code> / <code>feed_many</code>:</p>
<pre><code class="language-rust ignore">let range = group.feed_many(commands).await?;
group.when().committed().reaches(range).await;</code></pre>
<h4 id="log-position"><a class="header" href="#log-position">Log Position</a></h4>
<p>The same API works for the full log position (including uncommitted entries):</p>
<pre><code class="language-rust ignore">let log = group.when().log();

let new_cursor = log.advanced().await;
let new_cursor = log.changed().await;</code></pre>
<h2 id="index-and-cursor-types"><a class="header" href="#index-and-cursor-types">Index and Cursor Types</a></h2>
<pre><code class="language-rust ignore">/// A log index (0-based, where 0 is the sentinel "no entry")
pub struct Index(pub u64);

/// A Raft term number
pub struct Term(pub u64);

/// A (term, index) pair identifying a specific log position
pub struct Cursor { pub term: Term, pub index: Index }</code></pre>
<p>Both <code>Index</code> and <code>Term</code> provide:</p>
<ul>
<li><code>zero()</code>, <code>one()</code> — constants</li>
<li><code>is_zero()</code> — check for sentinel</li>
<li><code>prev()</code>, <code>next()</code> — saturating arithmetic</li>
<li><code>distance(other)</code> — absolute difference</li>
</ul>
<h2 id="bonds"><a class="header" href="#bonds">Bonds</a></h2>
<p><code>group.bonds()</code> returns a <code>Bonds</code> handle — a watchable, ordered collection of all active bonds:</p>
<pre><code class="language-rust ignore">let bonds = group.bonds();

// Iterate current bonds
for bond in bonds.iter() {
    println!("Bonded to: {}", bond.peer_id());
}</code></pre>
<p>Bonds carry Raft messages, heartbeats, and sync traffic between group members. See the <a href="subsystems/internals/bonds.html">Bonds deep dive</a> for internals.</p>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h2>
<p>A common pattern for group-aware applications:</p>
<pre><code class="language-rust ignore">let group = network.groups()
    .with_key(key)
    .with_state_machine(MyMachine::new())
    .join();

// Wait until we can serve traffic
group.when().online().await;

if group.is_leader() {
    // Run leader-specific tasks
    run_leader_loop(&amp;group).await;
} else {
    // Run follower-specific tasks
    run_follower_loop(&amp;group).await;
}

// React to leadership changes
loop {
    let new_leader = group.when().leader_changed().await;
    if group.is_leader() {
        // Transition to leader role
    } else {
        // Transition to follower role
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="collections-1"><a class="header" href="#collections-1">Collections</a></h1>
<p>The <strong>Collections</strong> subsystem provides replicated, eventually consistent data
structures that feel like local Rust collections but are automatically
synchronized across all participating nodes using Raft consensus.</p>
<pre><code class="language-text">┌────────────────────────────────────────────────────────────────────────┐
│                   Collections                                          │
│                                                                        │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐ ┌─────────────────┐ │
│  │   Map    │ │   Vec    │ │   Set    │ │  DEPQ  │ │   Register &lt;T&gt;  │ │
│  │ &lt;K, V&gt;   │ │ &lt;T&gt;      │ │ &lt;T&gt;      │ │&lt;P,K,V&gt; │ │                 │ │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └───┬────┘ └────────┬────────┘ │
│       └────────────┴────────────┴─┬─────────┴───────────────┘          │
│                                   │                                    │
│                                   │                                    │
│                                   │                                    │
│                  ┌────────────────▼───────────────────┐                │
│                  │    Groups (Raft Consensus)         │                │
│                  │    One group per collection        │                │
│                  └────────────────────────────────────┘                │
└────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Each collection instance creates its own Raft consensus group. Different
collections (or the same type with different <code>StoreId</code>s) run as independent
groups and can span different subsets of the network.</p>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick start</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{Map, StoreId};

// On every node — using the same StoreId joins the same group
let prices = Map::&lt;String, f64&gt;::writer(&amp;network, StoreId::from("prices"));

// Wait until the collection is online
prices.when().online().await;

// Write (only available on writers)
let version = prices.insert("ETH".into(), 3812.50).await?;

// Wait for the write to be committed
prices.when().reaches(version).await;

// Read (available on both writers and readers)
assert_eq!(prices.get(&amp;"ETH".into()), Some(3812.50));</code></pre>
<h2 id="writer--reader-split"><a class="header" href="#writer--reader-split">Writer / Reader split</a></h2>
<p>Every collection type offers two modes, distinguished at the <strong>type level</strong>
using a const-generic boolean:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Type alias</th><th>Can write?</th><th>Leadership priority</th></tr>
</thead>
<tbody>
<tr><td><strong>Writer</strong></td><td><code>MapWriter&lt;K,V&gt;</code>, <code>VecWriter&lt;T&gt;</code>, <code>RegisterWriter&lt;T&gt;</code>, etc.</td><td>Yes</td><td>Normal</td></tr>
<tr><td><strong>Reader</strong></td><td><code>MapReader&lt;K,V&gt;</code>, <code>VecReader&lt;T&gt;</code>, <code>RegisterReader&lt;T&gt;</code>, etc.</td><td>No</td><td>Deprioritized</td></tr>
</tbody>
</table>
</div>
<p>Both modes provide identical read access. Readers automatically use
<code>deprioritize_leadership()</code> in their consensus configuration to reduce the
chance of being elected leader, since leaders handle write forwarding.</p>
<pre><code class="language-rust ignore">// Writer — can read AND write
let w = Map::&lt;String, u64&gt;::writer(&amp;network, store_id);

// Reader — can only read, lower chance of becoming leader
let r = Map::&lt;String, u64&gt;::reader(&amp;network, store_id);</code></pre>
<h2 id="available-collections"><a class="header" href="#available-collections">Available collections</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collection</th><th>Description</th><th>Backing structure</th></tr>
</thead>
<tbody>
<tr><td><a href="#map"><code>Map&lt;K, V&gt;</code></a></td><td>Unordered key-value map</td><td><code>im::HashMap</code> (deterministic)</td></tr>
<tr><td><a href="#vec"><code>Vec&lt;T&gt;</code></a></td><td>Ordered, index-addressable sequence</td><td><code>im::Vector</code></td></tr>
<tr><td><a href="#set"><code>Set&lt;T&gt;</code></a></td><td>Unordered set of unique values</td><td><code>im::HashSet</code> (deterministic)</td></tr>
<tr><td><a href="#register"><code>Register&lt;T&gt;</code></a></td><td>Single-value register</td><td><code>Option&lt;T&gt;</code></td></tr>
<tr><td><a href="#priorityqueue"><code>PriorityQueue&lt;P, K, V&gt;</code></a></td><td>Double-ended priority queue</td><td><code>im::HashMap</code> + <code>im::OrdMap</code></td></tr>
</tbody>
</table>
</div>
<p>All collections use the <a href="https://docs.rs/im"><code>im</code> crate</a> for their internal
state, which provides <strong>O(1) structural sharing</strong> — cloning a snapshot of the
entire collection is essentially free. This is critical for the snapshot-based
state sync mechanism.</p>
<h2 id="trait-requirements"><a class="header" href="#trait-requirements">Trait requirements</a></h2>
<p>Collections use blanket-implemented marker traits to constrain their type
parameters:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Required bounds</th><th>Used by</th></tr>
</thead>
<tbody>
<tr><td><code>Value</code></td><td><code>Clone + Debug + Serialize + DeserializeOwned + Hash + PartialEq + Eq + Send + Sync + 'static</code></td><td>All element/value types</td></tr>
<tr><td><code>Key</code></td><td><code>Clone + Serialize + DeserializeOwned + Hash + PartialEq + Eq + Send + Sync + 'static</code></td><td>Map keys, Set elements, PQ keys</td></tr>
<tr><td><code>OrderedKey</code></td><td><code>Key + Ord</code></td><td>PriorityQueue priorities</td></tr>
</tbody>
</table>
</div>
<p>These traits are automatically implemented for any type that satisfies their
bounds — you never need to implement them manually.</p>
<h2 id="storeid-and-group-identity"><a class="header" href="#storeid-and-group-identity">StoreId and group identity</a></h2>
<p>Each collection derives its Raft group identity from:</p>
<ol>
<li><strong>A fixed prefix</strong> per collection type (e.g., <code>"mosaik_collections_map"</code>)</li>
<li><strong>The <code>StoreId</code></strong> — a <code>UniqueId</code> you provide at construction time</li>
<li><strong>The Rust type names</strong> of the type parameters</li>
</ol>
<p>This means <code>Map::&lt;String, u64&gt;::writer(&amp;net, id)</code> and
<code>Map::&lt;u32, u64&gt;::writer(&amp;net, id)</code> will join <strong>different</strong> groups even with
the same <code>StoreId</code>, because the key type differs.</p>
<h2 id="version-tracking"><a class="header" href="#version-tracking">Version tracking</a></h2>
<p>All mutating operations return a <code>Version</code>, which wraps the Raft log <code>Index</code>
at which the mutation will be committed:</p>
<pre><code class="language-rust ignore">let version: Version = map.insert("key".into(), 42).await?;

// Wait until the mutation is committed and visible
map.when().reaches(version).await;</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error handling</a></h2>
<p>All write operations return <code>Result&lt;Version, Error&lt;T&gt;&gt;</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Error::Offline(T)</code></td><td>The node is temporarily offline. The value that failed is returned for retry.</td></tr>
<tr><td><code>Error::NetworkDown</code></td><td>The network is permanently down. The collection is no longer usable.</td></tr>
</tbody>
</table>
</div>
<h2 id="syncconfig"><a class="header" href="#syncconfig">SyncConfig</a></h2>
<p>Collections use a snapshot-based state sync mechanism to bring lagging
followers up to date. The <code>SyncConfig</code> controls this behavior:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fetch_batch_size</code></td><td><code>2000</code></td><td>Items per batch during snapshot transfer</td></tr>
<tr><td><code>snapshot_ttl</code></td><td><code>10s</code></td><td>How long a snapshot stays valid after last access</td></tr>
<tr><td><code>snapshot_request_timeout</code></td><td><code>15s</code></td><td>Timeout waiting for a <code>SnapshotReady</code> response</td></tr>
<tr><td><code>fetch_timeout</code></td><td><code>5s</code></td><td>Timeout per <code>FetchDataResponse</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Important:</strong> Different <code>SyncConfig</code> values produce different group
signatures. Collections using different configs will <strong>not</strong> see each other.</p>
</blockquote>
<pre><code class="language-rust ignore">use mosaik::collections::{Map, StoreId, SyncConfig};
use std::time::Duration;

let config = SyncConfig::default()
    .with_fetch_batch_size(5000)
    .with_snapshot_ttl(Duration::from_secs(30));

let map = Map::&lt;String, u64&gt;::writer_with_config(&amp;network, store_id, config);</code></pre>
<h2 id="how-snapshot-sync-works"><a class="header" href="#how-snapshot-sync-works">How snapshot sync works</a></h2>
<ol>
<li>A lagging follower sends a <code>RequestSnapshot</code> to the leader.</li>
<li>The leader wraps the request as a special command and replicates it.</li>
<li>When committed, <strong>all</strong> peers create a snapshot at the same log position.</li>
<li>The follower fetches snapshot data in batches from available peers.</li>
<li>Once complete, the follower installs the snapshot and replays any buffered
commands received during sync.</li>
</ol>
<p>Because <code>im</code> data structures support O(1) cloning, creating a snapshot is
nearly instant regardless of collection size.</p>
<h2 id="deterministic-hashing"><a class="header" href="#deterministic-hashing">Deterministic hashing</a></h2>
<p>Map and Set use <code>BuildHasherDefault&lt;DefaultHasher&gt;</code> (SipHash-1-3 with a fixed
zero seed) for their internal <code>im::HashMap</code> / <code>im::HashSet</code>. This ensures
that <strong>iteration order is identical across all nodes</strong> for the same logical
state — a requirement for snapshot sync to produce consistent chunked
transfers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="map"><a class="header" href="#map">Map</a></h1>
<p><code>Map&lt;K, V&gt;</code> is a replicated, unordered, eventually consistent key-value map.
Internally it is backed by an <code>im::HashMap</code> with a deterministic hasher.</p>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{Map, StoreId, SyncConfig};

// Writer — can read and write
let map = Map::&lt;String, u64&gt;::writer(&amp;network, StoreId::from("balances"));

// Writer with custom sync config
let map = Map::&lt;String, u64&gt;::writer_with_config(&amp;network, store_id, config);

// Reader — read-only, deprioritized for leadership
let map = Map::&lt;String, u64&gt;::reader(&amp;network, store_id);

// Reader with custom sync config
let map = Map::&lt;String, u64&gt;::reader_with_config(&amp;network, store_id, config);

// Aliases: new() == writer(), new_with_config() == writer_with_config()
let map = Map::&lt;String, u64&gt;::new(&amp;network, store_id);</code></pre>
<h2 id="read-operations"><a class="header" href="#read-operations">Read operations</a></h2>
<p>Available on both writers and readers. All reads operate on the <strong>local
committed state</strong> — they are non-blocking and never touch the network.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>len() -&gt; usize</code></td><td>O(1)</td><td>Number of entries</td></tr>
<tr><td><code>is_empty() -&gt; bool</code></td><td>O(1)</td><td>Whether the map is empty</td></tr>
<tr><td><code>contains_key(&amp;K) -&gt; bool</code></td><td>O(log n)</td><td>Test if a key exists</td></tr>
<tr><td><code>get(&amp;K) -&gt; Option&lt;V&gt;</code></td><td>O(log n)</td><td>Get a clone of the value for a key</td></tr>
<tr><td><code>iter() -&gt; impl Iterator&lt;Item = (K, V)&gt;</code></td><td>O(1)*</td><td>Iterate over all key-value pairs</td></tr>
<tr><td><code>keys() -&gt; impl Iterator&lt;Item = K&gt;</code></td><td>O(1)*</td><td>Iterate over all keys</td></tr>
<tr><td><code>values() -&gt; impl Iterator&lt;Item = V&gt;</code></td><td>O(1)*</td><td>Iterate over all values</td></tr>
<tr><td><code>version() -&gt; Version</code></td><td>O(1)</td><td>Current committed state version</td></tr>
<tr><td><code>when() -&gt; &amp;When</code></td><td>O(1)</td><td>Access the state observer</td></tr>
</tbody>
</table>
</div>
<p>* Iterator creation is O(1) due to <code>im::HashMap</code>’s structural sharing; full
iteration is O(n).</p>
<pre><code class="language-rust ignore">// Read the current state
if let Some(balance) = map.get(&amp;"alice".into()) {
    println!("Alice's balance: {balance}");
}

// Snapshot iteration — takes a structural clone, then iterates
for (key, value) in map.iter() {
    println!("{key}: {value}");
}</code></pre>
<h2 id="write-operations"><a class="header" href="#write-operations">Write operations</a></h2>
<p>Only available on <code>MapWriter&lt;K, V&gt;</code>. All writes go through Raft consensus and
return the <code>Version</code> at which the mutation will be committed.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>insert(K, V) -&gt; Result&lt;Version, Error&lt;(K, V)&gt;&gt;</code></td><td>Insert or update a key-value pair</td></tr>
<tr><td><code>compare_exchange(K, Option&lt;V&gt;, Option&lt;V&gt;) -&gt; Result&lt;Version, Error&lt;(K, Option&lt;V&gt;, Option&lt;V&gt;)&gt;&gt;</code></td><td>Atomic compare-and-swap for a key</td></tr>
<tr><td><code>remove(&amp;K) -&gt; Result&lt;Version, Error&lt;K&gt;&gt;</code></td><td>Remove a key</td></tr>
<tr><td><code>extend(impl IntoIterator&lt;Item = (K, V)&gt;) -&gt; Result&lt;Version, Error&lt;Vec&lt;(K, V)&gt;&gt;&gt;</code></td><td>Batch insert</td></tr>
<tr><td><code>clear() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>Remove all entries</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">// Insert a single entry
let v = map.insert("ETH".into(), 3812).await?;

// Batch insert
let v = map.extend([
    ("BTC".into(), 105_000),
    ("SOL".into(), 178),
]).await?;

// Wait for the batch to commit
map.when().reaches(v).await;

// Remove
map.remove(&amp;"SOL".into()).await?;

// Atomic compare-and-swap: update only if current value matches
let v = map.compare_exchange(
    "ETH".into(),
    Some(3812),   // expected current value
    Some(3900),   // new value
).await?;
map.when().reaches(v).await;

// Compare-and-swap to insert a new key (expected = None)
let v = map.compare_exchange(
    "DOGE".into(),
    None,          // key must not exist
    Some(42),      // value to insert
).await?;

// Compare-and-swap to delete (new = None)
let v = map.compare_exchange(
    "DOGE".into(),
    Some(42),      // expected current value
    None,          // remove the key
).await?;

// Clear everything
map.clear().await?;</code></pre>
<h3 id="compare-and-swap-semantics"><a class="header" href="#compare-and-swap-semantics">Compare-and-swap semantics</a></h3>
<p><code>compare_exchange</code> atomically checks the value associated with a key and only
applies the mutation if it matches the <code>expected</code> parameter:</p>
<ul>
<li><strong><code>key</code></strong>: The key to operate on.</li>
<li><strong><code>expected</code></strong>: The expected current value (<code>None</code> means the key must not
exist).</li>
<li><strong><code>new</code></strong>: The value to write if the expectation holds (<code>None</code> removes the
key).</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>expected</code></th><th><code>new</code></th><th>Effect when matched</th></tr>
</thead>
<tbody>
<tr><td><code>None</code></td><td><code>Some(v)</code></td><td>Insert a new key-value pair</td></tr>
<tr><td><code>Some(old)</code></td><td><code>Some(new)</code></td><td>Update an existing value</td></tr>
<tr><td><code>Some(old)</code></td><td><code>None</code></td><td>Remove the key</td></tr>
<tr><td><code>None</code></td><td><code>None</code></td><td>No-op (key must not exist)</td></tr>
</tbody>
</table>
</div>
<p>If the current value does not match <code>expected</code>, the operation is a <strong>no-op</strong> —
it still commits to the Raft log (incrementing the version) but does not
mutate the map.</p>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error handling</a></h2>
<p>On failure, the values you attempted to write are returned inside the error so
you can retry without re-creating them:</p>
<pre><code class="language-rust ignore">match map.insert("key".into(), expensive_value).await {
    Ok(version) =&gt; println!("committed at {version}"),
    Err(Error::Offline((key, value))) =&gt; {
        // Node is temporarily offline — retry later
        println!("offline, got {key} and {value} back");
    }
    Err(Error::NetworkDown) =&gt; {
        // Permanent failure
    }
}</code></pre>
<h2 id="status--observation"><a class="header" href="#status--observation">Status &amp; observation</a></h2>
<pre><code class="language-rust ignore">// Wait until the map is online
map.when().online().await;

// Wait for a specific version
let v = map.insert("x".into(), 1).await?;
map.when().reaches(v).await;

// Wait for any new commit
map.when().updated().await;

// Detect going offline
map.when().offline().await;</code></pre>
<h2 id="group-identity-1"><a class="header" href="#group-identity-1">Group identity</a></h2>
<p>The group key for a <code>Map&lt;K, V&gt;</code> is derived from:</p>
<pre><code class="language-text">UniqueId::from("mosaik_collections_map")
    .derive(store_id)
    .derive(type_name::&lt;K&gt;())
    .derive(type_name::&lt;V&gt;())
</code></pre>
<p>Two maps with the same <code>StoreId</code> but different key or value types will be in
completely separate consensus groups.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec"><a class="header" href="#vec">Vec</a></h1>
<p><code>Vec&lt;T&gt;</code> is a replicated, ordered, index-addressable sequence. Internally it
is backed by <code>im::Vector&lt;T&gt;</code>, which provides efficient push/pop at both ends
and O(log n) random access.</p>
<h2 id="construction-1"><a class="header" href="#construction-1">Construction</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{Vec, StoreId, SyncConfig};

// Writer — can read and write
let vec = Vec::&lt;String&gt;::writer(&amp;network, StoreId::from("events"));

// Writer with custom sync config
let vec = Vec::&lt;String&gt;::writer_with_config(&amp;network, store_id, config);

// Reader — read-only, deprioritized for leadership
let vec = Vec::&lt;String&gt;::reader(&amp;network, store_id);

// Reader with custom sync config
let vec = Vec::&lt;String&gt;::reader_with_config(&amp;network, store_id, config);

// Aliases: new() == writer(), new_with_config() == writer_with_config()
let vec = Vec::&lt;String&gt;::new(&amp;network, store_id);</code></pre>
<h2 id="read-operations-1"><a class="header" href="#read-operations-1">Read operations</a></h2>
<p>Available on both writers and readers. Reads operate on the local committed
state and never touch the network.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>len() -&gt; usize</code></td><td>O(1)</td><td>Number of elements</td></tr>
<tr><td><code>is_empty() -&gt; bool</code></td><td>O(1)</td><td>Whether the vector is empty</td></tr>
<tr><td><code>get(u64) -&gt; Option&lt;T&gt;</code></td><td>O(log n)</td><td>Get element at index</td></tr>
<tr><td><code>front() -&gt; Option&lt;T&gt;</code></td><td>O(log n)</td><td>First element</td></tr>
<tr><td><code>head() -&gt; Option&lt;T&gt;</code></td><td>O(log n)</td><td>Alias for <code>front()</code></td></tr>
<tr><td><code>back() -&gt; Option&lt;T&gt;</code></td><td>O(log n)</td><td>Last element</td></tr>
<tr><td><code>last() -&gt; Option&lt;T&gt;</code></td><td>O(log n)</td><td>Alias for <code>back()</code></td></tr>
<tr><td><code>contains(&amp;T) -&gt; bool</code></td><td>O(n)</td><td>Test if a value is in the vector</td></tr>
<tr><td><code>index_of(&amp;T) -&gt; Option&lt;u64&gt;</code></td><td>O(n)</td><td>Find the index of a value</td></tr>
<tr><td><code>iter() -&gt; impl Iterator&lt;Item = T&gt;</code></td><td>O(1)*</td><td>Iterate over all elements</td></tr>
<tr><td><code>version() -&gt; Version</code></td><td>O(1)</td><td>Current committed state version</td></tr>
<tr><td><code>when() -&gt; &amp;When</code></td><td>O(1)</td><td>Access the state observer</td></tr>
</tbody>
</table>
</div>
<p>* Iterator creation is O(1) due to structural sharing; full traversal is O(n).</p>
<pre><code class="language-rust ignore">// Random access
if let Some(event) = vec.get(0) {
    println!("First event: {event}");
}

// Peek at ends
let newest = vec.back();
let oldest = vec.front();

// Linear search
if let Some(idx) = vec.index_of(&amp;"restart".into()) {
    println!("Found restart at index {idx}");
}</code></pre>
<h2 id="write-operations-1"><a class="header" href="#write-operations-1">Write operations</a></h2>
<p>Only available on <code>VecWriter&lt;T&gt;</code>. All writes go through Raft consensus.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>push_back(T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>O(1)*</td><td>Append to end</td></tr>
<tr><td><code>push_front(T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>O(1)*</td><td>Prepend to start</td></tr>
<tr><td><code>insert(u64, T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>O(log n)</td><td>Insert at index, shifting elements right</td></tr>
<tr><td><code>extend(impl IntoIterator&lt;Item = T&gt;) -&gt; Result&lt;Version, Error&lt;Vec&lt;T&gt;&gt;&gt;</code></td><td>O(k)*</td><td>Batch append</td></tr>
<tr><td><code>pop_back() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(1)*</td><td>Remove last element</td></tr>
<tr><td><code>pop_front() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(1)*</td><td>Remove first element</td></tr>
<tr><td><code>remove(u64) -&gt; Result&lt;Version, Error&lt;u64&gt;&gt;</code></td><td>O(log n)</td><td>Remove at index, shifting elements left</td></tr>
<tr><td><code>swap(u64, u64) -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(log n)</td><td>Swap two elements</td></tr>
<tr><td><code>truncate(usize) -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(log n)</td><td>Keep only the first <code>n</code> elements</td></tr>
<tr><td><code>clear() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(1)</td><td>Remove all elements</td></tr>
</tbody>
</table>
</div>
<p>* Amortized time complexity.</p>
<pre><code class="language-rust ignore">// Append
let v = vec.push_back("event-1".into()).await?;

// Prepend
vec.push_front("event-0".into()).await?;

// Batch append
let v = vec.extend(["a".into(), "b".into(), "c".into()]).await?;

// Random insert
vec.insert(2, "inserted".into()).await?;

// Remove from ends
vec.pop_back().await?;
vec.pop_front().await?;

// Remove at index
vec.remove(0).await?;

// Swap positions
vec.swap(0, 1).await?;

// Truncate and clear
vec.truncate(10).await?;
vec.clear().await?;</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error handling</a></h2>
<p>Writes return the failed value on <code>Error::Offline</code> so you can retry:</p>
<pre><code class="language-rust ignore">match vec.push_back(item).await {
    Ok(version) =&gt; {
        vec.when().reaches(version).await;
    }
    Err(Error::Offline(item)) =&gt; {
        // Retry with the same item later
    }
    Err(Error::NetworkDown) =&gt; {
        // Permanent failure
    }
}</code></pre>
<h2 id="status--observation-1"><a class="header" href="#status--observation-1">Status &amp; observation</a></h2>
<pre><code class="language-rust ignore">// Wait until online
vec.when().online().await;

// Wait for a specific committed version
let v = vec.push_back("x".into()).await?;
vec.when().reaches(v).await;

// Wait for any update
vec.when().updated().await;

// React to going offline
vec.when().offline().await;</code></pre>
<h2 id="group-identity-2"><a class="header" href="#group-identity-2">Group identity</a></h2>
<p>The group key for a <code>Vec&lt;T&gt;</code> is derived from:</p>
<pre><code class="language-text">UniqueId::from("mosaik_collections_vec")
    .derive(store_id)
    .derive(type_name::&lt;T&gt;())
</code></pre>
<p>Two vectors with the same <code>StoreId</code> but different element types will be in
separate consensus groups.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="set"><a class="header" href="#set">Set</a></h1>
<p><code>Set&lt;T&gt;</code> is a replicated, unordered, eventually consistent set of unique
values. Internally it is backed by an <code>im::HashSet</code> with a deterministic
hasher (SipHash-1-3 with a fixed zero seed), so iteration order is identical
across all nodes.</p>
<h2 id="construction-2"><a class="header" href="#construction-2">Construction</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{Set, StoreId, SyncConfig};

// Writer — can read and write
let set = Set::&lt;String&gt;::writer(&amp;network, StoreId::from("active-peers"));

// Writer with custom sync config
let set = Set::&lt;String&gt;::writer_with_config(&amp;network, store_id, config);

// Reader — read-only, deprioritized for leadership
let set = Set::&lt;String&gt;::reader(&amp;network, store_id);

// Reader with custom sync config
let set = Set::&lt;String&gt;::reader_with_config(&amp;network, store_id, config);

// Aliases: new() == writer(), new_with_config() == writer_with_config()
let set = Set::&lt;String&gt;::new(&amp;network, store_id);</code></pre>
<h2 id="read-operations-2"><a class="header" href="#read-operations-2">Read operations</a></h2>
<p>Available on both writers and readers.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>len() -&gt; usize</code></td><td>O(1)</td><td>Number of elements</td></tr>
<tr><td><code>is_empty() -&gt; bool</code></td><td>O(1)</td><td>Whether the set is empty</td></tr>
<tr><td><code>contains(&amp;T) -&gt; bool</code></td><td>O(log n)</td><td>Test membership</td></tr>
<tr><td><code>is_subset(&amp;Set&lt;T, W&gt;) -&gt; bool</code></td><td>O(n)</td><td>Test subset relationship</td></tr>
<tr><td><code>iter() -&gt; impl Iterator&lt;Item = T&gt;</code></td><td>O(1)*</td><td>Iterate over all elements</td></tr>
<tr><td><code>version() -&gt; Version</code></td><td>O(1)</td><td>Current committed state version</td></tr>
<tr><td><code>when() -&gt; &amp;When</code></td><td>O(1)</td><td>Access the state observer</td></tr>
</tbody>
</table>
</div>
<p>* Iterator creation is O(1); full traversal is O(n).</p>
<pre><code class="language-rust ignore">// Membership test
if set.contains(&amp;"node-42".into()) {
    println!("node-42 is active");
}

// Subset check between two sets (can differ in writer/reader mode)
if allowed.is_subset(&amp;active) {
    println!("all allowed nodes are active");
}

// Iteration
for peer in set.iter() {
    println!("active: {peer}");
}</code></pre>
<h2 id="write-operations-2"><a class="header" href="#write-operations-2">Write operations</a></h2>
<p>Only available on <code>SetWriter&lt;T&gt;</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>insert(T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>Insert a value (no-op if already present)</td></tr>
<tr><td><code>extend(impl IntoIterator&lt;Item = T&gt;) -&gt; Result&lt;Version, Error&lt;Vec&lt;T&gt;&gt;&gt;</code></td><td>Batch insert</td></tr>
<tr><td><code>remove(&amp;T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>Remove a value</td></tr>
<tr><td><code>clear() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>Remove all elements</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">// Insert
let v = set.insert("node-1".into()).await?;

// Batch insert
let v = set.extend(["node-2".into(), "node-3".into()]).await?;
set.when().reaches(v).await;

// Remove
set.remove(&amp;"node-1".into()).await?;

// Clear
set.clear().await?;</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error handling</a></h2>
<p>Writes return the failed value on <code>Error::Offline</code>:</p>
<pre><code class="language-rust ignore">match set.insert(value).await {
    Ok(version) =&gt; { /* committed */ }
    Err(Error::Offline(value)) =&gt; {
        // Retry later with the same value
    }
    Err(Error::NetworkDown) =&gt; {
        // Permanent failure
    }
}</code></pre>
<h2 id="status--observation-2"><a class="header" href="#status--observation-2">Status &amp; observation</a></h2>
<pre><code class="language-rust ignore">set.when().online().await;

let v = set.insert("x".into()).await?;
set.when().reaches(v).await;

set.when().updated().await;
set.when().offline().await;</code></pre>
<h2 id="group-identity-3"><a class="header" href="#group-identity-3">Group identity</a></h2>
<pre><code class="language-text">UniqueId::from("mosaik_collections_set")
    .derive(store_id)
    .derive(type_name::&lt;T&gt;())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="register"><a class="header" href="#register">Register</a></h1>
<p><code>Register&lt;T&gt;</code> is a replicated single-value register. It holds at most one
value at a time — writing a new value replaces the previous one entirely. This
is the distributed equivalent of a <code>tokio::sync::watch</code> channel: all nodes
observe the latest value.</p>
<p>Internally the state is simply an <code>Option&lt;T&gt;</code>, making the Register the
simplest collection in the mosaik toolkit.</p>
<h2 id="construction-3"><a class="header" href="#construction-3">Construction</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{Register, StoreId, SyncConfig};

// Writer — can read and write
let reg = Register::&lt;String&gt;::writer(&amp;network, StoreId::from("config"));

// Writer with custom sync config
let reg = Register::&lt;String&gt;::writer_with_config(&amp;network, store_id, config);

// Reader — read-only, deprioritized for leadership
let reg = Register::&lt;String&gt;::reader(&amp;network, store_id);

// Reader with custom sync config
let reg = Register::&lt;String&gt;::reader_with_config(&amp;network, store_id, config);

// Aliases: new() == writer(), new_with_config() == writer_with_config()
let reg = Register::&lt;String&gt;::new(&amp;network, store_id);</code></pre>
<h2 id="read-operations-3"><a class="header" href="#read-operations-3">Read operations</a></h2>
<p>Available on both writers and readers. Reads operate on the local committed
state and never touch the network.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>read() -&gt; Option&lt;T&gt;</code></td><td>O(1)</td><td>Get the current value</td></tr>
<tr><td><code>get() -&gt; Option&lt;T&gt;</code></td><td>O(1)</td><td>Alias for <code>read()</code></td></tr>
<tr><td><code>is_empty() -&gt; bool</code></td><td>O(1)</td><td>Whether the register holds a value</td></tr>
<tr><td><code>version() -&gt; Version</code></td><td>O(1)</td><td>Current committed state version</td></tr>
<tr><td><code>when() -&gt; &amp;When</code></td><td>O(1)</td><td>Access the state observer</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">// Read the current value
if let Some(config) = reg.read() {
    println!("Current config: {config}");
}

// Check if a value has been written
if reg.is_empty() {
    println!("No configuration set yet");
}</code></pre>
<h2 id="write-operations-3"><a class="header" href="#write-operations-3">Write operations</a></h2>
<p>Only available on <code>RegisterWriter&lt;T&gt;</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>write(T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>O(1)</td><td>Write a value (replaces any existing value)</td></tr>
<tr><td><code>set(T) -&gt; Result&lt;Version, Error&lt;T&gt;&gt;</code></td><td>O(1)</td><td>Alias for <code>write()</code></td></tr>
<tr><td><code>compare_exchange(Option&lt;T&gt;, Option&lt;T&gt;) -&gt; Result&lt;Version, Error&lt;(Option&lt;T&gt;, Option&lt;T&gt;)&gt;&gt;</code></td><td>O(1)</td><td>Atomic compare-and-swap</td></tr>
<tr><td><code>clear() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>O(1)</td><td>Remove the stored value</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">// Write a value
let v = reg.write("v1".into()).await?;

// Overwrite (replaces previous value)
let v = reg.write("v2".into()).await?;
reg.when().reaches(v).await;

// Using the alias
reg.set("v3".into()).await?;

// Atomic compare-and-swap: only writes if current value matches expected
let v = reg.compare_exchange(Some("v3".into()), Some("v4".into())).await?;
reg.when().reaches(v).await;
assert_eq!(reg.read(), Some("v4".to_string()));

// Compare-and-swap from empty to a value
reg.clear().await?;
let v = reg.compare_exchange(None, Some("first".into())).await?;
reg.when().reaches(v).await;

// Compare-and-swap to remove (set to None)
let v = reg.compare_exchange(Some("first".into()), None).await?;
reg.when().reaches(v).await;
assert!(reg.is_empty());

// Clear back to empty
reg.clear().await?;
assert!(reg.is_empty());</code></pre>
<h3 id="compare-and-swap-semantics-1"><a class="header" href="#compare-and-swap-semantics-1">Compare-and-swap semantics</a></h3>
<p><code>compare_exchange</code> atomically checks the current value of the register and
only applies the write if it matches the <code>current</code> parameter. This is useful
for optimistic concurrency control — multiple writers can attempt a swap, and
only the one whose expectation matches the actual state will succeed.</p>
<ul>
<li><strong><code>current</code></strong>: The expected current value (<code>None</code> means the register must be
empty).</li>
<li><strong><code>new</code></strong>: The value to write if the expectation holds (<code>None</code> clears the
register).</li>
</ul>
<p>If the current value does not match <code>current</code>, the operation is a <strong>no-op</strong> —
it still commits to the Raft log (incrementing the version) but does not
change the stored value.</p>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error handling</a></h2>
<p>Writes return the failed value on <code>Error::Offline</code> so you can retry:</p>
<pre><code class="language-rust ignore">match reg.write(value).await {
    Ok(version) =&gt; {
        reg.when().reaches(version).await;
    }
    Err(Error::Offline(value)) =&gt; {
        // Retry with the same value later
    }
    Err(Error::NetworkDown) =&gt; {
        // Permanent failure
    }
}</code></pre>
<h2 id="status--observation-3"><a class="header" href="#status--observation-3">Status &amp; observation</a></h2>
<pre><code class="language-rust ignore">// Wait until online
reg.when().online().await;

// Wait for a specific committed version
let v = reg.write("new-config".into()).await?;
reg.when().reaches(v).await;

// Wait for any update
reg.when().updated().await;

// React to going offline
reg.when().offline().await;</code></pre>
<h2 id="group-identity-4"><a class="header" href="#group-identity-4">Group identity</a></h2>
<p>The group key for a <code>Register&lt;T&gt;</code> is derived from:</p>
<pre><code class="language-text">UniqueId::from("mosaik_collections_register")
    .derive(store_id)
    .derive(type_name::&lt;T&gt;())
</code></pre>
<p>Two registers with the same <code>StoreId</code> but different value types will be in
separate consensus groups.</p>
<h2 id="when-to-use-register"><a class="header" href="#when-to-use-register">When to use Register</a></h2>
<p>Register is ideal for:</p>
<ul>
<li><strong>Configuration</strong> — a single shared config object replicated across the cluster</li>
<li><strong>Leader state</strong> — the current leader’s address or identity</li>
<li><strong>Latest snapshot</strong> — the most recent version of a computed result</li>
<li><strong>Feature flags</strong> — a single boolean or enum toggled cluster-wide</li>
</ul>
<p>If you need to store multiple values, use <a href="#map"><code>Map</code></a>, <a href="#vec"><code>Vec</code></a>,
or <a href="#set"><code>Set</code></a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="priorityqueue"><a class="header" href="#priorityqueue">PriorityQueue</a></h1>
<p><code>PriorityQueue&lt;P, K, V&gt;</code> is a replicated, eventually consistent double-ended
priority queue (DEPQ). Each entry has a <strong>priority</strong> (<code>P</code>), a unique <strong>key</strong>
(<code>K</code>), and a <strong>value</strong> (<code>V</code>). It supports efficient access to both the minimum
and maximum priority elements, key-based lookups, priority updates, and range
removals.</p>
<p>Internally it maintains two indexes:</p>
<ul>
<li><code>by_key: im::HashMap&lt;K, (P, V)&gt;</code> — O(log n) key lookups</li>
<li><code>by_priority: im::OrdMap&lt;P, im::HashMap&lt;K, V&gt;&gt;</code> — O(log n) min/max and range
operations</li>
</ul>
<p>Both indexes use deterministic hashers for consistent iteration order across
nodes.</p>
<h2 id="construction-4"><a class="header" href="#construction-4">Construction</a></h2>
<pre><code class="language-rust ignore">use mosaik::collections::{PriorityQueue, StoreId, SyncConfig};

// Writer — can read and write
let pq = PriorityQueue::&lt;u64, String, Order&gt;::writer(
    &amp;network,
    StoreId::from("orderbook"),
);

// Writer with custom sync config
let pq = PriorityQueue::&lt;u64, String, Order&gt;::writer_with_config(
    &amp;network, store_id, config,
);

// Reader — read-only, deprioritized for leadership
let pq = PriorityQueue::&lt;u64, String, Order&gt;::reader(&amp;network, store_id);

// Reader with custom sync config
let pq = PriorityQueue::&lt;u64, String, Order&gt;::reader_with_config(
    &amp;network, store_id, config,
);

// Aliases
let pq = PriorityQueue::&lt;u64, String, Order&gt;::new(&amp;network, store_id);
let pq = PriorityQueue::&lt;u64, String, Order&gt;::new_with_config(
    &amp;network, store_id, config,
);</code></pre>
<h2 id="read-operations-4"><a class="header" href="#read-operations-4">Read operations</a></h2>
<p>Available on both writers and readers.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Time</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>len() -&gt; usize</code></td><td>O(1)</td><td>Number of entries</td></tr>
<tr><td><code>is_empty() -&gt; bool</code></td><td>O(1)</td><td>Whether the queue is empty</td></tr>
<tr><td><code>contains_key(&amp;K) -&gt; bool</code></td><td>O(log n)</td><td>Test if a key exists</td></tr>
<tr><td><code>get(&amp;K) -&gt; Option&lt;V&gt;</code></td><td>O(log n)</td><td>Get the value for a key</td></tr>
<tr><td><code>get_priority(&amp;K) -&gt; Option&lt;P&gt;</code></td><td>O(log n)</td><td>Get the priority for a key</td></tr>
<tr><td><code>get_min() -&gt; Option&lt;(P, K, V)&gt;</code></td><td>O(log n)</td><td>Entry with the lowest priority</td></tr>
<tr><td><code>get_max() -&gt; Option&lt;(P, K, V)&gt;</code></td><td>O(log n)</td><td>Entry with the highest priority</td></tr>
<tr><td><code>min_priority() -&gt; Option&lt;P&gt;</code></td><td>O(log n)</td><td>Lowest priority value</td></tr>
<tr><td><code>max_priority() -&gt; Option&lt;P&gt;</code></td><td>O(log n)</td><td>Highest priority value</td></tr>
<tr><td><code>iter() -&gt; impl Iterator&lt;Item = (P, K, V)&gt;</code></td><td>—</td><td>Ascending priority order (alias for <code>iter_asc</code>)</td></tr>
<tr><td><code>iter_asc() -&gt; impl Iterator&lt;Item = (P, K, V)&gt;</code></td><td>—</td><td>Ascending priority order</td></tr>
<tr><td><code>iter_desc() -&gt; impl Iterator&lt;Item = (P, K, V)&gt;</code></td><td>—</td><td>Descending priority order</td></tr>
<tr><td><code>version() -&gt; Version</code></td><td>O(1)</td><td>Current committed state version</td></tr>
<tr><td><code>when() -&gt; &amp;When</code></td><td>O(1)</td><td>Access the state observer</td></tr>
</tbody>
</table>
</div>
<p>When multiple entries share the same priority, <code>get_min()</code> and <code>get_max()</code>
return an arbitrary entry from that priority bucket.</p>
<pre><code class="language-rust ignore">// Peek at extremes
if let Some((priority, key, value)) = pq.get_min() {
    println!("Best bid: {key} at priority {priority}");
}

// Look up by key
let price = pq.get_priority(&amp;"order-42".into());

// Iterate in order
for (priority, key, value) in pq.iter_desc() {
    println!("{priority}: {key} = {value:?}");
}</code></pre>
<h2 id="write-operations-4"><a class="header" href="#write-operations-4">Write operations</a></h2>
<p>Only available on <code>PriorityQueueWriter&lt;P, K, V&gt;</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>insert(P, K, V) -&gt; Result&lt;Version, Error&lt;(P, K, V)&gt;&gt;</code></td><td>Insert or update an entry</td></tr>
<tr><td><code>extend(impl IntoIterator&lt;Item = (P, K, V)&gt;) -&gt; Result&lt;Version, Error&lt;Vec&lt;(P, K, V)&gt;&gt;&gt;</code></td><td>Batch insert</td></tr>
<tr><td><code>update_priority(&amp;K, P) -&gt; Result&lt;Version, Error&lt;K&gt;&gt;</code></td><td>Change priority of an existing key</td></tr>
<tr><td><code>update_value(&amp;K, V) -&gt; Result&lt;Version, Error&lt;K&gt;&gt;</code></td><td>Change value of an existing key</td></tr>
<tr><td><code>compare_exchange_value(&amp;K, V, Option&lt;V&gt;) -&gt; Result&lt;Version, Error&lt;K&gt;&gt;</code></td><td>Atomic compare-and-swap on value</td></tr>
<tr><td><code>remove(&amp;K) -&gt; Result&lt;Version, Error&lt;K&gt;&gt;</code></td><td>Remove by key</td></tr>
<tr><td><code>remove_range(impl RangeBounds&lt;P&gt;) -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>Remove all entries in a priority range</td></tr>
<tr><td><code>clear() -&gt; Result&lt;Version, Error&lt;()&gt;&gt;</code></td><td>Remove all entries</td></tr>
</tbody>
</table>
</div>
<p>If <code>insert</code> is called with a key that already exists, both its priority and
value are updated. <code>update_priority</code> and <code>update_value</code> are no-ops if the key
doesn’t exist (they still commit to the log).</p>
<pre><code class="language-rust ignore">// Insert
let v = pq.insert(100, "order-1".into(), order).await?;

// Batch insert
let v = pq.extend([
    (100, "order-1".into(), order1),
    (200, "order-2".into(), order2),
]).await?;

// Update just the priority
pq.update_priority(&amp;"order-1".into(), 150).await?;

// Update just the value
pq.update_value(&amp;"order-1".into(), new_order).await?;

// Atomic compare-and-swap on value (priority is preserved)
let v = pq.compare_exchange_value(
    &amp;"order-1".into(),
    order1,        // expected current value
    Some(updated), // new value
).await?;

// Compare-and-swap to remove: expected matches, new is None
let v = pq.compare_exchange_value(
    &amp;"order-1".into(),
    updated,       // expected current value
    None,          // removes the entry
).await?;

// Remove a single entry
pq.remove(&amp;"order-2".into()).await?;

// Remove all entries with priority below 50
pq.remove_range(..50u64).await?;

// Remove entries in a range
pq.remove_range(10..=20).await?;

// Clear everything
pq.clear().await?;</code></pre>
<h3 id="range-syntax"><a class="header" href="#range-syntax">Range syntax</a></h3>
<p><code>remove_range</code> accepts any <code>RangeBounds&lt;P&gt;</code>, so all standard Rust range
syntaxes work:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>..cutoff</code></td><td>Priorities below <code>cutoff</code></td></tr>
<tr><td><code>..=cutoff</code></td><td>Priorities at or below <code>cutoff</code></td></tr>
<tr><td><code>cutoff..</code></td><td>Priorities at or above <code>cutoff</code></td></tr>
<tr><td><code>lo..hi</code></td><td>Priorities in <code>[lo, hi)</code></td></tr>
<tr><td><code>lo..=hi</code></td><td>Priorities in <code>[lo, hi]</code></td></tr>
<tr><td><code>..</code></td><td>All (equivalent to <code>clear()</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="compare-and-swap-semantics-2"><a class="header" href="#compare-and-swap-semantics-2">Compare-and-swap semantics</a></h3>
<p><code>compare_exchange_value</code> atomically checks the value of an existing entry and
only applies the mutation if it matches the <code>expected</code> parameter. Unlike
<code>compare_exchange</code> on <code>Map</code> and <code>Register</code>, this method operates <strong>only on the
value</strong> — the entry’s priority is always preserved.</p>
<ul>
<li><strong><code>key</code></strong>: The key of the entry to operate on (must already exist).</li>
<li><strong><code>expected</code></strong>: The expected current value (type <code>V</code>, not <code>Option&lt;V&gt;</code> — the
key must exist for the exchange to succeed).</li>
<li><strong><code>new</code></strong>: The replacement value. <code>Some(v)</code> updates the value in-place;
<code>None</code> removes the entire entry.</li>
</ul>
<p>If the key does not exist or its current value does not match <code>expected</code>, the
operation is a <strong>no-op</strong> — it commits to the Raft log but does not change the
queue.</p>
<blockquote>
<p><strong>Note:</strong> The entry’s priority is never changed by <code>compare_exchange_value</code>.
To atomically update priorities, use <code>update_priority</code> instead.</p>
</blockquote>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error handling</a></h2>
<p>Same pattern as other collections — failed values are returned for retry:</p>
<pre><code class="language-rust ignore">match pq.insert(priority, key, value).await {
    Ok(version) =&gt; { /* committed */ }
    Err(Error::Offline((priority, key, value))) =&gt; {
        // Retry later
    }
    Err(Error::NetworkDown) =&gt; {
        // Permanent failure
    }
}</code></pre>
<h2 id="status--observation-4"><a class="header" href="#status--observation-4">Status &amp; observation</a></h2>
<pre><code class="language-rust ignore">pq.when().online().await;

let v = pq.insert(100, "k".into(), val).await?;
pq.when().reaches(v).await;

pq.when().updated().await;
pq.when().offline().await;</code></pre>
<h2 id="dual-index-architecture"><a class="header" href="#dual-index-architecture">Dual-index architecture</a></h2>
<p>The DEPQ maintains two synchronized indexes:</p>
<pre><code class="language-text">by_key:      HashMap&lt;K, (P, V)&gt;     ← key lookups, membership tests
by_priority: OrdMap&lt;P, HashMap&lt;K, V&gt;&gt; ← min/max, range ops, ordered iteration
</code></pre>
<p>When a key is inserted or updated, both indexes are updated atomically within
the state machine’s <code>apply_batch</code>. During snapshot sync, only the <code>by_key</code>
index is serialized; the <code>by_priority</code> index is reconstructed on the receiving
side during <code>append</code>.</p>
<h2 id="group-identity-5"><a class="header" href="#group-identity-5">Group identity</a></h2>
<pre><code class="language-text">UniqueId::from("mosaik_collections_depq")
    .derive(store_id)
    .derive(type_name::&lt;P&gt;())
    .derive(type_name::&lt;K&gt;())
    .derive(type_name::&lt;V&gt;())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writerreader-pattern"><a class="header" href="#writerreader-pattern">Writer/Reader Pattern</a></h1>
<p>All mosaik collections share a common access-control pattern: every collection
type is parameterized by a const-generic boolean (<code>IS_WRITER</code>) that determines
whether the instance has write access.</p>
<pre><code class="language-text">                 ┌──────────────────┐
                 │  Collection&lt;T&gt;   │
                 │  const IS_WRITER │
                 └────────┬─────────┘
                          │
              ┌───────────┴───────────┐
              │                       │
       IS_WRITER = true        IS_WRITER = false
       ┌──────────────┐       ┌──────────────┐
       │    Writer    │       │    Reader    │
       │ read + write │       │  read-only   │
       │ normal leader│       │ deprioritized│
       │   priority   │       │   leader     │
       └──────────────┘       └──────────────┘
</code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h2>
<p>Each collection provides convenient type aliases:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collection</th><th>Writer type</th><th>Reader type</th></tr>
</thead>
<tbody>
<tr><td><code>Map&lt;K, V&gt;</code></td><td><code>MapWriter&lt;K, V&gt;</code></td><td><code>MapReader&lt;K, V&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>VecWriter&lt;T&gt;</code></td><td><code>VecReader&lt;T&gt;</code></td></tr>
<tr><td><code>Set&lt;T&gt;</code></td><td><code>SetWriter&lt;T&gt;</code></td><td><code>SetReader&lt;T&gt;</code></td></tr>
<tr><td><code>Register&lt;T&gt;</code></td><td><code>RegisterWriter&lt;T&gt;</code></td><td><code>RegisterReader&lt;T&gt;</code></td></tr>
<tr><td><code>PriorityQueue&lt;P, K, V&gt;</code></td><td><code>PriorityQueueWriter&lt;P, K, V&gt;</code></td><td><code>PriorityQueueReader&lt;P, K, V&gt;</code></td></tr>
</tbody>
</table>
</div>
<h2 id="construction-5"><a class="header" href="#construction-5">Construction</a></h2>
<p>Every collection offers the same set of constructors:</p>
<pre><code class="language-rust ignore">// Writer (default)
Collection::writer(&amp;network, store_id)
Collection::writer_with_config(&amp;network, store_id, sync_config)

// Convenience aliases for writer
Collection::new(&amp;network, store_id)
Collection::new_with_config(&amp;network, store_id, sync_config)

// Reader
Collection::reader(&amp;network, store_id)
Collection::reader_with_config(&amp;network, store_id, sync_config)</code></pre>
<p>The <code>StoreId</code> and <code>SyncConfig</code> must match between writers and readers for them
to join the same consensus group.</p>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How it works</a></h2>
<p>Internally, the const-generic boolean controls two things:</p>
<ol>
<li>
<p><strong>Method availability</strong> — Write methods (<code>insert</code>, <code>push_back</code>, <code>remove</code>,
etc.) are only implemented for <code>IS_WRITER = true</code>. This is enforced at
compile time.</p>
</li>
<li>
<p><strong>Leadership priority</strong> — Readers return a <code>ConsensusConfig</code> with
<code>deprioritize_leadership()</code>, which increases their election timeout. This
makes it less likely for a reader to become the Raft leader, keeping
leadership on writer nodes where write operations are handled directly
rather than being forwarded.</p>
</li>
</ol>
<pre><code class="language-rust ignore">// Inside every collection's StateMachine impl:
fn consensus_config(&amp;self) -&gt; Option&lt;ConsensusConfig&gt; {
    (!self.is_writer)
        .then(|| ConsensusConfig::default().deprioritize_leadership())
}</code></pre>
<h2 id="shared-read-api"><a class="header" href="#shared-read-api">Shared read API</a></h2>
<p>Both writers and readers have identical read access. The read methods are
implemented on <code>Collection&lt;T, IS_WRITER&gt;</code> without constraining <code>IS_WRITER</code>:</p>
<pre><code class="language-rust ignore">// Works on both MapWriter and MapReader
impl&lt;K: Key, V: Value, const IS_WRITER: bool&gt; Map&lt;K, V, IS_WRITER&gt; {
    pub fn len(&amp;self) -&gt; usize { ... }
    pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;V&gt; { ... }
    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = (K, V)&gt; { ... }
    pub fn when(&amp;self) -&gt; &amp;When { ... }
    pub fn version(&amp;self) -&gt; Version { ... }
}</code></pre>
<h2 id="trait-requirements-1"><a class="header" href="#trait-requirements-1">Trait requirements</a></h2>
<p>The type parameters for collection elements must satisfy blanket-implemented
trait bounds:</p>
<h3 id="value"><a class="header" href="#value">Value</a></h3>
<p>Required for all element and value types:</p>
<pre><code class="language-rust ignore">pub trait Value:
    Clone + Debug + Serialize + DeserializeOwned
    + Hash + PartialEq + Eq + Send + Sync + 'static
{}

// Blanket impl — any conforming type is a Value
impl&lt;T&gt; Value for T where T: Clone + Debug + Serialize + ... {}</code></pre>
<h3 id="key"><a class="header" href="#key">Key</a></h3>
<p>Required for map keys, set elements, and priority queue keys:</p>
<pre><code class="language-rust ignore">pub trait Key:
    Clone + Serialize + DeserializeOwned
    + Hash + PartialEq + Eq + Send + Sync + 'static
{}</code></pre>
<p>Note that <code>Key</code> does not require <code>Debug</code> (unlike <code>Value</code>).</p>
<h3 id="orderedkey"><a class="header" href="#orderedkey">OrderedKey</a></h3>
<p>Required for priority queue priorities:</p>
<pre><code class="language-rust ignore">pub trait OrderedKey: Key + Ord {}
impl&lt;T: Key + Ord&gt; OrderedKey for T {}</code></pre>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>All write operations return <code>Version</code>, which wraps the Raft log <code>Index</code> where
the mutation will be committed. Use it with the <code>When</code> API to synchronize:</p>
<pre><code class="language-rust ignore">let version = map.insert("key".into(), value).await?;
map.when().reaches(version).await;
// Now the insert is guaranteed to be committed</code></pre>
<p><code>Version</code> implements <code>Deref&lt;Target = Index&gt;</code>, <code>PartialOrd</code>, <code>Ord</code>, <code>Display</code>,
and <code>Copy</code>.</p>
<h2 id="when-collections"><a class="header" href="#when-collections">When (collections)</a></h2>
<p>The collections <code>When</code> is a thin wrapper around the groups <code>When</code> that exposes
collection-relevant observers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>online()</code></td><td>Resolves when the collection has joined and synced with the group</td></tr>
<tr><td><code>offline()</code></td><td>Resolves when the collection loses sync or leadership</td></tr>
<tr><td><code>updated()</code></td><td>Resolves when any new state version is committed</td></tr>
<tr><td><code>reaches(Version)</code></td><td>Resolves when committed state reaches at least the given version</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">// Typical lifecycle pattern
loop {
    collection.when().online().await;
    println!("online, version = {}", collection.version());

    // ... do work ...

    collection.when().offline().await;
    println!("went offline, waiting to reconnect...");
}</code></pre>
<h2 id="multiple-writers"><a class="header" href="#multiple-writers">Multiple writers</a></h2>
<p>Multiple nodes can be writers for the same collection simultaneously. All
writes are funneled through Raft consensus, so there is no conflict — every
write is serialized in the log and applied in the same order on all nodes.</p>
<pre><code class="language-rust ignore">// Node A
let map = Map::&lt;String, u64&gt;::writer(&amp;network, store_id);
map.insert("from-a".into(), 1).await?;

// Node B (same StoreId)
let map = Map::&lt;String, u64&gt;::writer(&amp;network, store_id);
map.insert("from-b".into(), 2).await?;

// Both nodes see both entries after sync</code></pre>
<h2 id="choosing-writer-vs-reader"><a class="header" href="#choosing-writer-vs-reader">Choosing writer vs. reader</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use a Writer when…</th><th>Use a Reader when…</th></tr>
</thead>
<tbody>
<tr><td>The node needs to modify the collection</td><td>The node only observes state</td></tr>
<tr><td>You want normal leadership election priority</td><td>You want to reduce leadership overhead</td></tr>
<tr><td>The node is in the “hot path” for writes</td><td>The node is a monitoring/dashboard node</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="raft-consensus"><a class="header" href="#raft-consensus">Raft Consensus</a></h1>
<p>Mosaik’s groups subsystem implements a <strong>modified Raft</strong> consensus algorithm
optimized for dynamic, self-organizing peer sets. This chapter covers the
differences from standard Raft and explains the internal implementation.</p>
<h2 id="standard-raft-recap"><a class="header" href="#standard-raft-recap">Standard Raft recap</a></h2>
<p>Raft organizes a cluster into a single <strong>leader</strong> and multiple <strong>followers</strong>.
The leader accepts client commands, appends them to a replicated log, and only
commits entries once a <strong>quorum</strong> (majority) of nodes has acknowledged them.
If the leader fails, an <strong>election</strong> promotes a new one.</p>
<h2 id="mosaiks-modifications"><a class="header" href="#mosaiks-modifications">Mosaik’s modifications</a></h2>
<h3 id="1-non-voting-followers-abstention"><a class="header" href="#1-non-voting-followers-abstention">1. Non-voting followers (Abstention)</a></h3>
<p>In standard Raft, every follower participates in elections and log replication
quorum counts. In mosaik, a follower can <strong>abstain</strong> from voting:</p>
<pre><code class="language-text">enum Vote {
    Granted,    // Standard yes vote
    Denied,     // Standard no vote
    Abstained,  // Mosaik-specific: "I'm too far behind to vote"
}
</code></pre>
<p>A follower abstains when it detects that it is <strong>lagging behind</strong> the
leader’s log and cannot verify log consistency. Abstaining removes the node
from the quorum denominator until it catches up. This prevents stale nodes
from blocking progress while still allowing them to receive new entries and
rejoin the quorum later.</p>
<h3 id="2-no-per-follower-tracking-on-the-leader"><a class="header" href="#2-no-per-follower-tracking-on-the-leader">2. No per-follower tracking on the leader</a></h3>
<p>Standard Raft leaders maintain <code>nextIndex[]</code> and <code>matchIndex[]</code> arrays to
track each follower’s log position. Mosaik’s leader does <strong>not</strong> maintain
per-follower state. Instead:</p>
<ul>
<li>Each <code>AppendEntriesResponse</code> includes the follower’s <code>last_log_index</code>.</li>
<li>The leader uses these responses to calculate commit progress dynamically.</li>
<li>This simplifies the leader and avoids stale state when group membership
changes frequently.</li>
</ul>
<h3 id="3-dynamic-quorum"><a class="header" href="#3-dynamic-quorum">3. Dynamic quorum</a></h3>
<p>Because nodes can abstain, the quorum denominator changes at runtime:</p>
<pre><code class="language-text">effective_quorum = (voting_nodes / 2) + 1
</code></pre>
<p>Where <code>voting_nodes = total_bonded_peers - abstaining_peers</code>. This allows
the cluster to make progress even when some nodes are syncing or offline,
as long as a majority of the <strong>voting</strong> members agree.</p>
<h3 id="4-distributed-catch-up-state-sync"><a class="header" href="#4-distributed-catch-up-state-sync">4. Distributed catch-up (state sync)</a></h3>
<p>When a follower falls too far behind to replay individual log entries, mosaik
uses a <strong>state sync</strong> mechanism rather than the leader shipping log snapshots:</p>
<ol>
<li>The follower sends a <code>RequestSnapshot</code> to the leader.</li>
<li>The leader wraps it as a command and replicates it through the log.</li>
<li><strong>All</strong> peers create a snapshot at the committed position of that command.</li>
<li>The follower fetches snapshot data in batches from <strong>multiple</strong> peers in
parallel, distributing the load.</li>
<li>Once complete, the follower installs the snapshot and replays any buffered
commands.</li>
</ol>
<p>This is fundamentally different from standard Raft’s approach where only the
leader sends snapshots.</p>
<h3 id="5-leadership-deprioritization"><a class="header" href="#5-leadership-deprioritization">5. Leadership deprioritization</a></h3>
<p>Nodes can configure longer election timeouts to reduce the probability of
becoming leader:</p>
<pre><code class="language-rust ignore">ConsensusConfig::default().deprioritize_leadership()</code></pre>
<p>This is used by collection readers, which prefer to leave leadership to writer
nodes.</p>
<h3 id="6-bootstrap-delay"><a class="header" href="#6-bootstrap-delay">6. Bootstrap delay</a></h3>
<p>The first term (<code>Term::zero()</code>) adds an extra <code>bootstrap_delay</code> (default 3s)
to the election timeout. This gives all nodes time to start, discover each
other, and form bonds before the first election fires.</p>
<h2 id="roles-and-state-transitions"><a class="header" href="#roles-and-state-transitions">Roles and state transitions</a></h2>
<pre><code class="language-text">          bootstrap_delay
               │
               ▼
     ┌────────────────┐     election timeout
     │    Follower     │─────────────────────┐
     │  (passive)      │                     │
     └────────┬───────┘                     │
              │ AppendEntries               │
              │ from leader                 ▼
              │                    ┌──────────────┐
              │                    │   Candidate   │
              │                    │ (requesting   │
              │                    │    votes)     │
              │                    └──────┬───────┘
              │                           │ majority
              │                           │ granted
              │                           ▼
              │                    ┌──────────────┐
              └────────────────────│    Leader     │
                 higher term       │ (active,      │
                 received          │  heartbeats)  │
                                   └──────────────┘
</code></pre>
<p>Each role has specific responsibilities:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Role</th><th>Key actions</th></tr>
</thead>
<tbody>
<tr><td><strong>Follower</strong></td><td>Respond to AppendEntries, vote in elections, forward commands to leader, detect leader failure via election timeout</td></tr>
<tr><td><strong>Candidate</strong></td><td>Increment term, vote for self, send RequestVote to all peers, transition to Leader on majority or back to Follower on higher term</td></tr>
<tr><td><strong>Leader</strong></td><td>Accept client commands, replicate log entries, send heartbeats, calculate dynamic quorum, commit entries, respond to forwarded queries</td></tr>
</tbody>
</table>
</div>
<h2 id="message-types"><a class="header" href="#message-types">Message types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Message</th><th>Direction</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>AppendEntries</code></td><td>Leader → Followers</td><td>Replicate log entries / heartbeat</td></tr>
<tr><td><code>AppendEntriesResponse</code></td><td>Follower → Leader</td><td>Acknowledge entries, report last log index, grant/deny/abstain</td></tr>
<tr><td><code>RequestVote</code></td><td>Candidate → All</td><td>Request vote for election</td></tr>
<tr><td><code>RequestVoteResponse</code></td><td>All → Candidate</td><td>Grant, deny, or abstain</td></tr>
<tr><td><code>Forward::Command</code></td><td>Follower → Leader</td><td>Forward client commands</td></tr>
<tr><td><code>Forward::CommandAck</code></td><td>Leader → Follower</td><td>Return assigned log indices</td></tr>
<tr><td><code>Forward::Query</code></td><td>Follower → Leader</td><td>Forward strong-consistency query</td></tr>
<tr><td><code>Forward::QueryResponse</code></td><td>Leader → Follower</td><td>Return query result and position</td></tr>
<tr><td><code>StateSync(...)</code></td><td>Peer ↔ Peer</td><td>State sync protocol messages</td></tr>
</tbody>
</table>
</div>
<h2 id="election-timing"><a class="header" href="#election-timing">Election timing</a></h2>
<p>Elections are controlled by <code>ConsensusConfig</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>heartbeat_interval</code></td><td>500ms</td><td>How often the leader sends heartbeats</td></tr>
<tr><td><code>heartbeat_jitter</code></td><td>150ms</td><td>Random jitter subtracted from heartbeat interval</td></tr>
<tr><td><code>election_timeout</code></td><td>2s</td><td>Base timeout before a follower starts an election</td></tr>
<tr><td><code>election_timeout_jitter</code></td><td>500ms</td><td>Random jitter added to election timeout</td></tr>
<tr><td><code>bootstrap_delay</code></td><td>3s</td><td>Extra delay for the very first election (term 0)</td></tr>
<tr><td><code>max_missed_heartbeats</code></td><td>10</td><td>Bond heartbeats missed before considering peer dead</td></tr>
</tbody>
</table>
</div>
<p>The randomized timeouts ensure that in most cases only one node transitions to
candidate at a time, avoiding split votes.</p>
<h2 id="command-flow"><a class="header" href="#command-flow">Command flow</a></h2>
<h3 id="write-path-leader"><a class="header" href="#write-path-leader">Write path (leader)</a></h3>
<pre><code class="language-text">Client ──execute()──► Leader
                        │
                        ├─ append to local log
                        ├─ send AppendEntries to followers
                        │
                        │◄── AppendEntriesResponse (majority)
                        │
                        ├─ advance commit index
                        ├─ apply to state machine
                        └─ return Result to client
</code></pre>
<h3 id="write-path-follower"><a class="header" href="#write-path-follower">Write path (follower)</a></h3>
<pre><code class="language-text">Client ──execute()──► Follower
                         │
                         ├─ Forward::Command to leader
                         │
                         │◄── Forward::CommandAck (assigned index)
                         │
                         │ ... wait for local commit to reach index ...
                         │
                         └─ return Result to client
</code></pre>
<h3 id="read-path"><a class="header" href="#read-path">Read path</a></h3>
<ul>
<li><strong>Weak consistency</strong>: Read directly from local state machine (any role).</li>
<li><strong>Strong consistency</strong>: Forward query to leader, which reads from its
always-up-to-date state machine and returns the result with commit position.</li>
</ul>
<h2 id="internal-types"><a class="header" href="#internal-types">Internal types</a></h2>
<p>The implementation is split across several modules:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Module</th><th>Contents</th></tr>
</thead>
<tbody>
<tr><td><code>raft/mod.rs</code></td><td><code>Raft&lt;S, M&gt;</code> — top-level driver, delegates to current role</td></tr>
<tr><td><code>raft/role.rs</code></td><td><code>Role</code> enum (Follower, Candidate, Leader), shared message handling</td></tr>
<tr><td><code>raft/shared.rs</code></td><td><code>Shared&lt;S, M&gt;</code> — state shared across all roles (storage, state machine, config)</td></tr>
<tr><td><code>raft/leader.rs</code></td><td>Leader-specific logic: heartbeats, replication, dynamic quorum</td></tr>
<tr><td><code>raft/follower.rs</code></td><td>Follower-specific logic: elections, forwarding, catch-up</td></tr>
<tr><td><code>raft/candidate.rs</code></td><td>Candidate-specific logic: vote collection, timeout</td></tr>
<tr><td><code>raft/protocol.rs</code></td><td>Message type definitions</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bonds-1"><a class="header" href="#bonds-1">Bonds</a></h1>
<p>Bonds are mosaik’s mechanism for maintaining a <strong>fully-connected mesh</strong> of
persistent, authenticated connections between all members of a group. Every
pair of peers in a group maintains exactly one bond.</p>
<h2 id="lifecycle-2"><a class="header" href="#lifecycle-2">Lifecycle</a></h2>
<p>A bond goes through three phases:</p>
<h3 id="1-establishment"><a class="header" href="#1-establishment">1. Establishment</a></h3>
<p>When two peers discover they belong to the same group (via discovery events),
one initiates a connection using the <code>/mosaik/groups/1</code> ALPN protocol.</p>
<p>The handshake uses <strong>mutual proof-of-knowledge</strong> to verify both sides know the
group key before exchanging any group-internal state:</p>
<pre><code class="language-text">Initiator                              Acceptor
    │                                      │
    ├── HandshakeStart ───────────────────►│
    │   · network_id                       │
    │   · group_id                         │
    │   · proof = blake3(session_secret    │
    │             ⊕ group_key)             │
    │   · known bonds list                 │
    │                                      │
    │                    verify proof       │
    │                                      │
    │◄─── HandshakeEnd ───────────────────┤
    │     · proof (acceptor's)             │
    │     · known bonds list               │
    │                                      │
    │   verify proof                       │
    │                                      │
    ▼   Bond established                   ▼
</code></pre>
<p>The <strong>proof</strong> is computed from the TLS session secret (unique per connection)
combined with the group key. This ensures:</p>
<ul>
<li>Both sides know the group key (authentication).</li>
<li>The proof cannot be replayed on a different connection (freshness).</li>
<li>No group secrets are transmitted in the clear.</li>
</ul>
<p>If proof verification fails, the connection is dropped immediately.</p>
<h3 id="2-steady-state-bondworker"><a class="header" href="#2-steady-state-bondworker">2. Steady state (BondWorker)</a></h3>
<p>Once established, a bond is managed by a <code>BondWorker</code> that:</p>
<ul>
<li>Sends and receives <strong>heartbeats</strong> (Ping/Pong) on a configurable interval.</li>
<li>Relays <strong>Raft messages</strong> between peers.</li>
<li>Propagates <strong>peer entry updates</strong> when discovery information changes.</li>
<li>Announces <strong>new bonds</strong> (<code>BondFormed</code>) so peers learn about topology changes.</li>
<li>Handles <strong>graceful departure</strong> when a peer is shutting down.</li>
</ul>
<h3 id="3-failure-and-reconnection"><a class="header" href="#3-failure-and-reconnection">3. Failure and reconnection</a></h3>
<p>If heartbeats are missed beyond the configured threshold, the bond is
considered failed and torn down. Both sides independently detect the failure.
When the peer reappears (via discovery), a new bond is established from
scratch with a fresh handshake.</p>
<h2 id="bondmessage-protocol"><a class="header" href="#bondmessage-protocol">BondMessage protocol</a></h2>
<p>After the handshake, all communication over a bond uses the <code>BondMessage</code>
enum:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Direction</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Ping</code></td><td>A → B</td><td>Heartbeat probe</td></tr>
<tr><td><code>Pong</code></td><td>B → A</td><td>Heartbeat response</td></tr>
<tr><td><code>Departure</code></td><td>Either</td><td>Graceful shutdown notification</td></tr>
<tr><td><code>PeerEntryUpdate(PeerEntry)</code></td><td>Either</td><td>Discovery information changed</td></tr>
<tr><td><code>BondFormed(BondId, PeerId)</code></td><td>Either</td><td>Announce new bond to populate topology</td></tr>
<tr><td><code>Raft(Bytes)</code></td><td>Either</td><td>Wrapped Raft protocol message</td></tr>
</tbody>
</table>
</div>
<p>All messages are serialized with <strong>postcard</strong> and framed with
<code>LengthDelimitedCodec</code> over a QUIC bidirectional stream (via <code>Link&lt;P&gt;</code>).</p>
<h2 id="heartbeat-mechanism"><a class="header" href="#heartbeat-mechanism">Heartbeat mechanism</a></h2>
<p>The <code>Heartbeat</code> struct tracks liveness:</p>
<pre><code class="language-rust ignore">struct Heartbeat {
    tick: Interval,        // fires every `base - jitter` to `base`
    last_recv: Instant,    // last time we received a Ping or Pong
    missed: u64,           // how many consecutive ticks without a response
    max_missed: u64,       // threshold from ConsensusConfig (default: 10)
    alert: Notify,         // signals when threshold is exceeded
}</code></pre>
<p>On each tick:</p>
<ol>
<li>Check if <code>last_recv</code> was recent enough.</li>
<li>If not, increment <code>missed</code>.</li>
<li>If <code>missed ≥ max_missed</code>, notify the alert future — the bond worker
tears down the bond.</li>
</ol>
<p>Receiving any message from the peer resets the counter:</p>
<pre><code class="language-rust ignore">heartbeat.reset(); // sets missed = 0 and refreshes last_recv</code></pre>
<p>Timing uses <strong>jitter</strong> to prevent synchronized heartbeat storms. The actual
interval for each tick is randomized between <code>base - jitter</code> and <code>base</code>.</p>
<h2 id="bond-identity"><a class="header" href="#bond-identity">Bond identity</a></h2>
<p>Each bond is identified by a <code>BondId</code>:</p>
<pre><code class="language-rust ignore">type BondId = UniqueId;</code></pre>
<p>The <code>BondId</code> is derived deterministically from both peer identities and the
group key, so both sides compute the same identifier independently.</p>
<h2 id="topology-tracking"><a class="header" href="#topology-tracking">Topology tracking</a></h2>
<p>Every group maintains a <code>Bonds</code> collection (accessible via
<code>Group::bonds()</code> or <code>When::bonds()</code>). This is an immutable set of all
currently active bonds in the group, including bonds between <strong>other</strong> peers
(learned via <code>BondFormed</code> messages).</p>
<p>This topology awareness lets each peer know the full mesh state, which is used
for:</p>
<ul>
<li>Dynamic quorum calculations in Raft.</li>
<li>Determining when enough peers are connected to start elections.</li>
<li>Providing the topology snapshot for state sync coordination.</li>
</ul>
<h2 id="connection-handling"><a class="header" href="#connection-handling">Connection handling</a></h2>
<p>The <code>Acceptor</code> struct implements the <code>ProtocolHandler</code> trait for the
<code>/mosaik/groups/1</code> ALPN:</p>
<pre><code class="language-text">Incoming connection
       │
       ▼
  Wrap in Link&lt;BondMessage&gt;
       │
       ▼
  ensure_known_peer()
       │
       ▼
  wait_for_handshake()
  · receive HandshakeStart
  · verify proof
  · send HandshakeEnd
       │
       ▼
  ensure_same_network()
       │
       ▼
  Hand off to Group worker
</code></pre>
<p>If any step fails, the connection is dropped cleanly. The group worker then
decides whether to accept the bond (it may already have one with that peer)
and spawns a <code>BondWorker</code> if accepted.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="state-synchronization-1"><a class="header" href="#state-synchronization-1">State Synchronization</a></h1>
<p>When a new peer joins a group or falls too far behind the leader’s log, it
needs a <strong>snapshot</strong> of the current state rather than replaying potentially
thousands of log entries. Mosaik implements a distributed state sync mechanism
that spreads the load across all group members.</p>
<h2 id="why-not-leader-only-snapshots"><a class="header" href="#why-not-leader-only-snapshots">Why not leader-only snapshots?</a></h2>
<p>In standard Raft, the leader ships snapshots to lagging followers. This has
two problems:</p>
<ol>
<li><strong>Leader bottleneck</strong> — the leader must serialize and transmit potentially
large state to each lagging follower.</li>
<li><strong>Snapshot inconsistency</strong> — the snapshot must be taken at a consistent
point, which may block the leader.</li>
</ol>
<p>Mosaik solves both by having <strong>all peers</strong> participate in snapshot creation and
distribution.</p>
<h2 id="the-six-step-process"><a class="header" href="#the-six-step-process">The six-step process</a></h2>
<pre><code class="language-text">1. Follower             2. Leader              3. All peers
   detects lag              wraps request         create snapshot
   ────────────             as log entry          at committed
   sends                    ────────────          position
   RequestSnapshot          replicates it         ──────────────

4. Follower             5. Follower            6. Follower
   discovers which          fetches batches       installs snapshot
   peers have               from multiple         and resumes
   snapshots                peers in parallel     normal operation
   ──────────────           ─────────────────     ──────────────────
</code></pre>
<h3 id="step-1-detect-lag"><a class="header" href="#step-1-detect-lag">Step 1: Detect lag</a></h3>
<p>A follower realizes it is behind when it receives an <code>AppendEntries</code> message
referencing a log prefix it does not have. It sends a <code>StateSync</code> message
to the leader requesting a snapshot.</p>
<h3 id="step-2-replicate-the-request"><a class="header" href="#step-2-replicate-the-request">Step 2: Replicate the request</a></h3>
<p>The leader wraps the snapshot request as a special log entry and replicates
it through the normal Raft consensus path. This ensures all peers see the
request at the <strong>same log position</strong>.</p>
<h3 id="step-3-create-snapshots"><a class="header" href="#step-3-create-snapshots">Step 3: Create snapshots</a></h3>
<p>When each peer commits the snapshot request entry, it creates a point-in-time
snapshot of its state machine. Because all peers see the request at the same
committed index, <strong>all snapshots are consistent</strong> — they represent the same
logical state.</p>
<p>The <code>im</code> crate’s persistent data structures make snapshotting O(1) by
sharing structure with the live state (copy-on-write).</p>
<h3 id="step-4-discover-snapshot-sources"><a class="header" href="#step-4-discover-snapshot-sources">Step 4: Discover snapshot sources</a></h3>
<p>The follower queries peers to find out which ones have a snapshot available
for the requested position. Snapshots have a <strong>TTL</strong> (default 10 seconds),
so they eventually expire if not fetched.</p>
<h3 id="step-5-parallel-fetching"><a class="header" href="#step-5-parallel-fetching">Step 5: Parallel fetching</a></h3>
<p>The follower fetches snapshot data in <strong>batches</strong> from multiple peers
simultaneously:</p>
<pre><code class="language-text">Follower ──batch request──► Peer A  (items 0..2000)
           batch request──► Peer B  (items 2000..4000)
           batch request──► Peer C  (items 4000..6000)
                   ...
</code></pre>
<p>Each batch contains up to <code>fetch_batch_size</code> (default 2000) items. By
distributing fetches across peers, the load is balanced and the follower
receives data faster.</p>
<h3 id="step-6-install-and-resume"><a class="header" href="#step-6-install-and-resume">Step 6: Install and resume</a></h3>
<p>Once all batches are received, the follower:</p>
<ol>
<li>Installs the snapshot as its new state machine state.</li>
<li>Updates its committed cursor to the snapshot position.</li>
<li>Replays any log entries received <strong>after</strong> the snapshot position.</li>
<li>Resumes normal follower operation (including voting).</li>
</ol>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<h3 id="snapshotstatemachine"><a class="header" href="#snapshotstatemachine"><code>SnapshotStateMachine</code></a></h3>
<p>State machines that support sync must implement:</p>
<pre><code class="language-rust ignore">trait SnapshotStateMachine: StateMachine {
    type Snapshot: Snapshot;

    fn snapshot(&amp;self) -&gt; Self::Snapshot;
    fn install_snapshot(&amp;mut self, items: Vec&lt;SnapshotItem&gt;);
}</code></pre>
<ul>
<li><code>snapshot()</code> creates a serializable snapshot of the current state.</li>
<li><code>install_snapshot()</code> replaces the state with data received from peers.</li>
</ul>
<h3 id="snapshot"><a class="header" href="#snapshot"><code>Snapshot</code></a></h3>
<p>The snapshot itself is iterable:</p>
<pre><code class="language-rust ignore">trait Snapshot {
    fn len(&amp;self) -&gt; usize;
    fn into_items(self) -&gt; impl Iterator&lt;Item = SnapshotItem&gt;;
}</code></pre>
<p>Each collection type implements this — for example, <code>MapSnapshot</code> yields
key-value pairs as serialized <code>SnapshotItem</code> bytes.</p>
<h3 id="snapshotitem"><a class="header" href="#snapshotitem"><code>SnapshotItem</code></a></h3>
<pre><code class="language-rust ignore">struct SnapshotItem {
    key: Bytes,
    value: Bytes,
}</code></pre>
<p>The generic key/value format allows any collection type to participate in the
same sync protocol.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>State sync behavior is controlled by <code>SyncConfig</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fetch_batch_size</code></td><td>2000</td><td>Maximum items per batch request</td></tr>
<tr><td><code>snapshot_ttl</code></td><td>10s</td><td>How long a snapshot remains available</td></tr>
<tr><td><code>snapshot_request_timeout</code></td><td>15s</td><td>Timeout for requesting a snapshot from peers</td></tr>
<tr><td><code>fetch_timeout</code></td><td>5s</td><td>Timeout for each batch fetch operation</td></tr>
</tbody>
</table>
</div>
<h3 id="tuning-tips"><a class="header" href="#tuning-tips">Tuning tips</a></h3>
<ul>
<li><strong>Large state</strong>: Increase <code>fetch_batch_size</code> to reduce round trips, but
watch memory usage.</li>
<li><strong>Slow networks</strong>: Increase <code>fetch_timeout</code> and <code>snapshot_request_timeout</code>.</li>
<li><strong>Fast churn</strong>: Increase <code>snapshot_ttl</code> if snapshots expire before followers
can fetch them.</li>
</ul>
<h2 id="log-replay-sync"><a class="header" href="#log-replay-sync">Log replay sync</a></h2>
<p>For groups that use <code>Storage</code> (log persistence) instead of in-memory state,
a <code>LogReplaySync</code> alternative exists. Instead of shipping snapshots, the
joining peer replays log entries from a <strong>replay provider</strong> — another peer
that streams its stored log entries.</p>
<p>This approach is simpler but only works when:</p>
<ul>
<li>The log fits in available storage.</li>
<li>Replay is fast enough relative to new entries arriving.</li>
</ul>
<p>The <code>replay</code> module provides <code>ReplayProvider</code> and <code>ReplaySession</code> types for
this path.</p>
<h2 id="collections-and-state-sync"><a class="header" href="#collections-and-state-sync">Collections and state sync</a></h2>
<p>All built-in collection types (<code>Map</code>, <code>Vec</code>, <code>Set</code>, <code>PriorityQueue</code>) implement
<code>SnapshotStateMachine</code>. Their internal state machines produce snapshots using
the <code>im</code> crate’s persistent data structures:</p>
<pre><code class="language-text">MapStateMachine ──snapshot()──► MapSnapshot (HashMap entries)
VecStateMachine ──snapshot()──► VecSnapshot (indexed entries)
SetStateMachine ──snapshot()──► SetSnapshot (set members)
DepqStateMachine ──snapshot()──► PriorityQueueSnapshot (by_key + by_priority)
</code></pre>
<p>The dual-index structure of <code>PriorityQueue</code> is preserved across sync — both
the <code>by_key</code> and <code>by_priority</code> indices are transmitted and reconstructed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wire-protocol"><a class="header" href="#wire-protocol">Wire Protocol</a></h1>
<p>All peer-to-peer communication in mosaik flows over <strong>QUIC</strong> streams, using a
consistent framing layer built on <code>Link&lt;P&gt;</code>. This chapter explains the protocol
stack from the transport up to application messages.</p>
<h2 id="protocol-stack"><a class="header" href="#protocol-stack">Protocol stack</a></h2>
<pre><code class="language-text">┌─────────────────────────────────┐
│  Application Messages           │  BondMessage, Datum, CatalogSync, ...
├─────────────────────────────────┤
│  postcard serialization         │  compact binary encoding (no_std, varint)
├─────────────────────────────────┤
│  LengthDelimitedCodec framing   │  4-byte big-endian length prefix
├─────────────────────────────────┤
│  QUIC bidirectional stream      │  SendStream + RecvStream
├─────────────────────────────────┤
│  iroh / quinn transport         │  QUIC with TLS 1.3, hole-punching
└─────────────────────────────────┘
</code></pre>
<h2 id="linkp"><a class="header" href="#linkp"><code>Link&lt;P&gt;</code></a></h2>
<p>The <code>Link&lt;P&gt;</code> type is the core abstraction for typed, bidirectional
communication over a QUIC stream:</p>
<pre><code class="language-rust ignore">struct Link&lt;P: Protocol&gt; {
    connection: Connection,
    cancel: CancellationToken,
    writer: FramedWrite&lt;SendStream, LengthDelimitedCodec&gt;,
    reader: FramedRead&lt;RecvStream, LengthDelimitedCodec&gt;,
}</code></pre>
<h3 id="the-protocol-trait"><a class="header" href="#the-protocol-trait">The <code>Protocol</code> trait</a></h3>
<p>Every protocol declares its <strong>ALPN</strong> (Application-Layer Protocol Negotiation)
identifier:</p>
<pre><code class="language-rust ignore">trait Protocol: Serialize + DeserializeOwned + Send + 'static {
    const ALPN: &amp;'static [u8];
}</code></pre>
<p>ALPN identifiers are exchanged during the TLS handshake, so peers agree on the
protocol before any application data flows. Mosaik uses these ALPNs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ALPN</th><th>Protocol type</th><th>Subsystem</th></tr>
</thead>
<tbody>
<tr><td><code>/mosaik/announce</code></td><td><code>AnnounceMessage</code></td><td>Discovery (gossip)</td></tr>
<tr><td><code>/mosaik/catalog-sync</code></td><td><code>CatalogSync</code></td><td>Discovery (catalog)</td></tr>
<tr><td><code>/mosaik/streams/1.0</code></td><td><code>Datum</code> impl</td><td>Streams</td></tr>
<tr><td><code>/mosaik/groups/1</code></td><td><code>BondMessage</code></td><td>Groups (bonds)</td></tr>
</tbody>
</table>
</div>
<h3 id="creating-a-link"><a class="header" href="#creating-a-link">Creating a link</a></h3>
<p>Links are created by either connecting to a peer or accepting an incoming
connection:</p>
<pre><code class="language-rust ignore">// Outgoing
let link = Link::&lt;BondMessage&gt;::connect(&amp;endpoint, node_addr).await?;

// Incoming (in a ProtocolHandler)
let link = Link::&lt;BondMessage&gt;::accept(connecting).await?;</code></pre>
<h3 id="sending-and-receiving"><a class="header" href="#sending-and-receiving">Sending and receiving</a></h3>
<pre><code class="language-rust ignore">// Send a message (serialized with postcard, length-prefixed)
link.send(BondMessage::Ping).await?;

// Receive a message (read length prefix, deserialize with postcard)
let msg: BondMessage = link.recv().await?;</code></pre>
<p>Under the hood:</p>
<ol>
<li><code>send()</code> serializes the message with <code>postcard::to_allocvec()</code>.</li>
<li>The resulting bytes are written through <code>FramedWrite</code> which prepends a
4-byte big-endian length prefix.</li>
<li><code>recv()</code> reads the length prefix from <code>FramedRead</code>, reads exactly that
many bytes, and deserializes with <code>postcard::from_bytes()</code>.</li>
</ol>
<h3 id="splitting-a-link"><a class="header" href="#splitting-a-link">Splitting a link</a></h3>
<p>For concurrent send/receive, a link can be split:</p>
<pre><code class="language-rust ignore">let (writer, reader) = link.split();

// In one task:
writer.send(msg).await?;

// In another task:
let msg = reader.recv().await?;

// Rejoin if needed:
let link = Link::join(writer, reader);</code></pre>
<h3 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h3>
<p>Every link carries a <code>CancellationToken</code>. When cancelled, both send and
receive operations return immediately. This is used for graceful shutdown:</p>
<pre><code class="language-rust ignore">link.cancel(); // signals both sides to stop</code></pre>
<h2 id="wire-format"><a class="header" href="#wire-format">Wire format</a></h2>
<h3 id="postcard-encoding"><a class="header" href="#postcard-encoding">postcard encoding</a></h3>
<p><a href="https://docs.rs/postcard">Postcard</a> is a <code>#[no_std]</code>-compatible binary
serialization format based on <strong>variable-length integers</strong> (varints). It
produces very compact output:</p>
<ul>
<li><code>u8</code> → 1 byte</li>
<li>Small <code>u32</code> → 1 byte (varint)</li>
<li>Enum variant → 1 byte discriminant + payload</li>
<li>Strings → varint length + UTF-8 bytes</li>
<li><code>Vec&lt;T&gt;</code> → varint length + elements</li>
</ul>
<p>This keeps message sizes minimal, which matters for high-frequency heartbeats
and Raft messages.</p>
<h3 id="framing"><a class="header" href="#framing">Framing</a></h3>
<p>Each message on the wire looks like:</p>
<pre><code class="language-text">┌──────────────┬───────────────────────────────┐
│ Length (4B)   │ postcard-encoded payload       │
│ big-endian    │                               │
└──────────────┴───────────────────────────────┘
</code></pre>
<p>The <code>LengthDelimitedCodec</code> from the <code>tokio-util</code> crate handles this
automatically. It supports messages up to 2³² - 1 bytes (4 GiB), though in
practice mosaik messages are typically under a few kilobytes.</p>
<h2 id="quic-transport"><a class="header" href="#quic-transport">QUIC transport</a></h2>
<p>Mosaik uses <strong>iroh</strong> (built on <strong>quinn</strong>) for QUIC transport. Key features:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Benefit</th></tr>
</thead>
<tbody>
<tr><td><strong>TLS 1.3</strong></td><td>All connections encrypted, session secrets used for bond proofs</td></tr>
<tr><td><strong>Multiplexed streams</strong></td><td>Multiple logical channels over one connection</td></tr>
<tr><td><strong>NAT traversal</strong></td><td>Built-in hole-punching and relay fallback</td></tr>
<tr><td><strong>Connection migration</strong></td><td>Connections survive IP changes</td></tr>
<tr><td><strong>mDNS discovery</strong></td><td>Automatic peer discovery on local networks</td></tr>
</tbody>
</table>
</div>
<h3 id="bidirectional-streams"><a class="header" href="#bidirectional-streams">Bidirectional streams</a></h3>
<p>Each <code>Link&lt;P&gt;</code> uses a single QUIC bidirectional stream. This means:</p>
<ul>
<li>One stream per bond connection.</li>
<li>One stream per catalog sync session.</li>
<li>One stream per producer-consumer pair.</li>
</ul>
<p>QUIC’s multiplexing means these streams don’t interfere with each other even
when sharing the same underlying UDP connection.</p>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error handling</a></h2>
<p>Link operations return <code>std::io::Error</code>. Common failure modes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Cause</th><th>Recovery</th></tr>
</thead>
<tbody>
<tr><td>Connection closed</td><td>Peer shut down or network failure</td><td>Reconnect via discovery</td></tr>
<tr><td>Deserialization error</td><td>Protocol version mismatch or corruption</td><td>Drop connection</td></tr>
<tr><td>Timeout</td><td>Peer unresponsive</td><td>Heartbeat detection → reconnect</td></tr>
<tr><td>Cancelled</td><td>Local shutdown</td><td>Graceful cleanup</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deterministic-hashing-1"><a class="header" href="#deterministic-hashing-1">Deterministic Hashing</a></h1>
<p>In a distributed replicated system, all peers must arrive at the <strong>exact same
state</strong> after applying the same sequence of operations. Mosaik’s collections
use deterministic hashing to guarantee consistent behavior across nodes.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>Rust’s default <code>HashMap</code> and <code>HashSet</code> use <strong>RandomState</strong> — a hasher seeded
with random data at process startup. This means:</p>
<ul>
<li>Iteration order differs between processes.</li>
<li>Two nodes applying the same inserts will have different internal layouts.</li>
<li>Snapshots of hash-based structures would differ even with identical contents.</li>
</ul>
<p>For replicated state machines, this is unacceptable.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The solution</a></h2>
<p>Mosaik’s <code>Map</code> and <code>Set</code> collections use a <strong>zero-seeded deterministic
hasher</strong>:</p>
<pre><code class="language-rust ignore">type DeterministicHasher = BuildHasherDefault&lt;DefaultHasher&gt;;</code></pre>
<p><code>BuildHasherDefault&lt;DefaultHasher&gt;</code> constructs a <code>DefaultHasher</code> (SipHash)
with a fixed zero seed on every call. This ensures:</p>
<ol>
<li><strong>Same input → same hash</strong> across all nodes and restarts.</li>
<li><strong>Same insertion order → same internal layout</strong> in the hash table.</li>
<li><strong>Snapshots are byte-identical</strong> when state is identical.</li>
</ol>
<h2 id="where-its-used"><a class="header" href="#where-its-used">Where it’s used</a></h2>
<h3 id="collections-2"><a class="header" href="#collections-2">Collections</a></h3>
<p>All hash-based collections use the deterministic hasher internally:</p>
<ul>
<li><code>Map&lt;K, V&gt;</code> uses <code>im::HashMap&lt;K, V, DeterministicHasher&gt;</code>.</li>
<li><code>Set&lt;V&gt;</code> uses <code>im::HashSet&lt;V, DeterministicHasher&gt;</code>.</li>
</ul>
<p>The <code>im</code> crate’s persistent hash structures accept a custom hasher parameter,
which mosaik sets to the zero-seeded variant.</p>
<h3 id="ordered-collections"><a class="header" href="#ordered-collections">Ordered collections</a></h3>
<p><code>Vec</code> and <code>PriorityQueue</code> do not use hashing for their primary index:</p>
<ul>
<li><code>Vec</code> uses <code>im::Vector</code> (a balanced tree indexed by position).</li>
<li><code>PriorityQueue</code> uses:
<ul>
<li><code>im::HashMap</code> (deterministic hasher) for key → value+priority lookup.</li>
<li><code>im::OrdMap</code> for priority-ordered access (requires <code>Ord</code>, not hashing).</li>
</ul>
</li>
</ul>
<h2 id="identity-derivation"><a class="header" href="#identity-derivation">Identity derivation</a></h2>
<p>Beyond collection hashing, determinism matters for <strong>identity</strong>:</p>
<h3 id="uniqueid"><a class="header" href="#uniqueid">UniqueId</a></h3>
<p>Group and store identities are derived deterministically from their inputs:</p>
<pre><code class="language-rust ignore">// GroupId is derived from key + network
let group_id = UniqueId::new(&amp;key, &amp;network_id);

// StoreId is derived from group + type signature
let store_id = StoreId::new(&amp;group_id, &amp;type_signature);</code></pre>
<p>This uses <code>blake3</code> hashing, which is inherently deterministic.</p>
<h3 id="type-signatures"><a class="header" href="#type-signatures">Type signatures</a></h3>
<p>Collection state machines compute a <strong>signature</strong> from their Rust type names:</p>
<pre><code class="language-rust ignore">fn signature() -&gt; Digest {
    Digest::from(
        std::any::type_name::&lt;MapStateMachine&lt;K, V&gt;&gt;()
    )
}</code></pre>
<p>This ensures that two collections are only considered the same store if they
have identical key and value types. A <code>Map&lt;String, u64&gt;</code> and a
<code>Map&lt;String, i64&gt;</code> will have different <code>StoreId</code> values and will never
attempt to sync with each other.</p>
<h2 id="snapshot-consistency"><a class="header" href="#snapshot-consistency">Snapshot consistency</a></h2>
<p>Deterministic hashing is critical for snapshot-based state sync:</p>
<pre><code class="language-text">Node A state: { "alice" → 1, "bob" → 2 }
Node B state: { "alice" → 1, "bob" → 2 }

With deterministic hashing:
  Node A snapshot bytes == Node B snapshot bytes  ✓

With random hashing:
  Node A snapshot bytes != Node B snapshot bytes  ✗
  (different internal bucket layout)
</code></pre>
<p>When a joining peer fetches snapshot batches from multiple source peers, the
items must be compatible. Deterministic hashing ensures all sources produce
the same serialized representation for identical logical state.</p>
<h2 id="the-im-crate"><a class="header" href="#the-im-crate">The <code>im</code> crate</a></h2>
<p>Mosaik uses the <a href="https://docs.rs/im"><code>im</code></a> crate for persistent
(copy-on-write) data structures. Key properties:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Benefit</th></tr>
</thead>
<tbody>
<tr><td><strong>Structural sharing</strong></td><td>O(1) snapshot via <code>clone()</code> — only divergent nodes are copied</td></tr>
<tr><td><strong>Custom hasher</strong></td><td>Accepts <code>BuildHasherDefault&lt;DefaultHasher&gt;</code> for determinism</td></tr>
<tr><td><strong>Thread-safe clones</strong></td><td><code>Arc</code>-based sharing, safe to snapshot from one task and iterate in another</td></tr>
<tr><td><strong>Balanced trees</strong></td><td><code>OrdMap</code> and <code>Vector</code> use RRB trees with O(log n) operations</td></tr>
</tbody>
</table>
</div>
<p>The O(1) cloning is especially important for state sync — creating a snapshot
does not block the state machine from processing new commands.</p>
<h2 id="trait-requirements-2"><a class="header" href="#trait-requirements-2">Trait requirements</a></h2>
<p>The deterministic hashing strategy imposes trait bounds on collection keys and
values:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Required by</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Hash</code></td><td><code>Map</code> keys, <code>Set</code> values</td><td>Deterministic bucket placement</td></tr>
<tr><td><code>Eq</code></td><td><code>Map</code> keys, <code>Set</code> values</td><td>Equality comparison for collision resolution</td></tr>
<tr><td><code>Clone</code></td><td>All keys and values</td><td>Structural sharing in <code>im</code> data structures</td></tr>
<tr><td><code>Serialize + DeserializeOwned</code></td><td>All keys and values</td><td>Snapshot and replication encoding</td></tr>
<tr><td><code>Send + Sync + 'static</code></td><td>All keys and values</td><td>Cross-task sharing</td></tr>
<tr><td><code>Ord</code></td><td><code>PriorityQueue</code> priorities</td><td>Ordered access in <code>OrdMap</code></td></tr>
</tbody>
</table>
</div>
<p>These are codified as blanket trait aliases:</p>
<pre><code class="language-rust ignore">// Satisfied by types that are Hash + Eq + Clone + Serialize + DeserializeOwned + Send + Sync + 'static
trait Key {}

// Adds Ord to Key requirements
trait OrderedKey {}

// Clone + Serialize + DeserializeOwned + Send + Sync + 'static (no Hash/Eq)
trait Value {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>This chapter lists every configuration struct in mosaik, its fields, default
values, and how the pieces fit together.</p>
<h2 id="networkbuilder-top-level"><a class="header" href="#networkbuilder-top-level"><code>NetworkBuilder</code> (top-level)</a></h2>
<p>The entry point for creating a mosaik network. All nested configs are
accessible through fluent builder methods.</p>
<pre><code class="language-rust ignore">use mosaik::Network;

let network = Network::builder()
    .network_id("my-network")
    .mdns_discovery(true)
    .discovery(|d| d.events_backlog(200))
    .streams(|s| s.with_backoff(my_backoff))
    .groups(|g| g.handshake_timeout(Duration::from_secs(5)))
    .build()
    .await?;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>network_id</code></td><td><code>NetworkId</code></td><td><strong>required</strong></td><td>Unique identifier for this network</td></tr>
<tr><td><code>relay_mode</code></td><td><code>iroh::RelayMode</code></td><td><code>RelayMode::Default</code></td><td>Relay server mode for NAT/firewall traversal</td></tr>
<tr><td><code>mdns_discovery</code></td><td><code>bool</code></td><td><code>false</code></td><td>Enable mDNS local network peer discovery</td></tr>
<tr><td><code>addresses</code></td><td><code>BTreeSet&lt;SocketAddr&gt;</code></td><td>empty (all interfaces)</td><td>Local bind addresses</td></tr>
<tr><td><code>secret_key</code></td><td><code>SecretKey</code></td><td>random</td><td>Ed25519 key for peer identity</td></tr>
<tr><td><code>discovery</code></td><td><code>DiscoveryConfigBuilder</code></td><td>see below</td><td>Nested discovery config</td></tr>
<tr><td><code>streams</code></td><td><code>StreamsConfigBuilder</code></td><td>see below</td><td>Nested streams config</td></tr>
<tr><td><code>groups</code></td><td><code>GroupsConfigBuilder</code></td><td>see below</td><td>Nested groups config</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note</strong>: <code>secret_key</code> determines the <code>PeerId</code>. If omitted, a random key
is generated on each run, giving the node a new identity every time.
Specifying a fixed key is only recommended for <strong>bootstrap nodes</strong> that need
a stable, well-known peer ID across restarts.</p>
</blockquote>
<hr>
<h2 id="discoveryconfig"><a class="header" href="#discoveryconfig"><code>discovery::Config</code></a></h2>
<p>Controls peer discovery, gossip, and catalog maintenance.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>events_backlog</code></td><td><code>usize</code></td><td><code>100</code></td><td>Past events retained in event watchers</td></tr>
<tr><td><code>bootstrap_peers</code></td><td><code>Vec&lt;EndpointAddr&gt;</code></td><td>empty</td><td>Initial peers to connect to on startup</td></tr>
<tr><td><code>tags</code></td><td><code>Vec&lt;Tag&gt;</code></td><td>empty</td><td>Tags advertised in local <code>PeerEntry</code></td></tr>
<tr><td><code>purge_after</code></td><td><code>Duration</code></td><td><code>300s</code> (5 min)</td><td>Time before stale peer entries are purged</td></tr>
<tr><td><code>max_time_drift</code></td><td><code>Duration</code></td><td><code>10s</code></td><td>Maximum acceptable timestamp drift</td></tr>
<tr><td><code>announce_interval</code></td><td><code>Duration</code></td><td><code>15s</code></td><td>Interval between presence announcements</td></tr>
<tr><td><code>announce_jitter</code></td><td><code>f32</code></td><td><code>0.5</code></td><td>Max jitter factor on announce interval</td></tr>
<tr><td><code>graceful_departure_window</code></td><td><code>Duration</code></td><td><code>500ms</code></td><td>Wait for departure gossip to propagate</td></tr>
</tbody>
</table>
</div>
<p>Builder methods <code>with_bootstrap(peers)</code> and <code>with_tags(tags)</code> accept either a
single item or an iterator (via <code>IntoIterOrSingle</code>):</p>
<pre><code class="language-rust ignore">Network::builder()
    .discovery(|d| d
        .with_bootstrap(peer_addr)          // single peer
        .with_tags(["validator", "relay"])   // multiple tags
        .purge_after(Duration::from_secs(600))
    )</code></pre>
<hr>
<h2 id="streamsconfig"><a class="header" href="#streamsconfig"><code>streams::Config</code></a></h2>
<p>Controls stream consumer reconnection behavior.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>backoff</code></td><td><code>BackoffFactory</code></td><td>Exponential, 5 min max</td><td>Retry policy for consumer stream connections</td></tr>
</tbody>
</table>
</div>
<p>Custom backoff example:</p>
<pre><code class="language-rust ignore">use mosaik::streams::backoff::ExponentialBackoff;

Network::builder()
    .streams(|s| s.with_backoff(ExponentialBackoff {
        max_elapsed_time: Some(Duration::from_secs(120)),
        ..Default::default()
    }))</code></pre>
<hr>
<h2 id="groupsconfig"><a class="header" href="#groupsconfig"><code>groups::Config</code></a></h2>
<p>Controls bond establishment.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>handshake_timeout</code></td><td><code>Duration</code></td><td><code>2s</code></td><td>Timeout for bond handshake with remote peers</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="consensusconfig-1"><a class="header" href="#consensusconfig-1"><code>ConsensusConfig</code></a></h2>
<p>Consensus parameters that <strong>must be identical</strong> across all members of a group.
These values are hashed into the <code>GroupId</code>, so any mismatch creates a different
group.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>heartbeat_interval</code></td><td><code>Duration</code></td><td><code>500ms</code></td><td>Bond heartbeat interval</td></tr>
<tr><td><code>heartbeat_jitter</code></td><td><code>Duration</code></td><td><code>150ms</code></td><td>Max heartbeat jitter</td></tr>
<tr><td><code>max_missed_heartbeats</code></td><td><code>u32</code></td><td><code>10</code></td><td>Missed heartbeats before bond is considered dead</td></tr>
<tr><td><code>election_timeout</code></td><td><code>Duration</code></td><td><code>2s</code></td><td>Raft election timeout (must exceed heartbeat interval)</td></tr>
<tr><td><code>election_timeout_jitter</code></td><td><code>Duration</code></td><td><code>500ms</code></td><td>Election timeout randomization</td></tr>
<tr><td><code>bootstrap_delay</code></td><td><code>Duration</code></td><td><code>3s</code></td><td>Extra delay for the first election (term 0)</td></tr>
<tr><td><code>forward_timeout</code></td><td><code>Duration</code></td><td><code>2s</code></td><td>Timeout for forwarding commands to leader</td></tr>
<tr><td><code>query_timeout</code></td><td><code>Duration</code></td><td><code>2s</code></td><td>Timeout for leader to respond to queries</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">use mosaik::groups::ConsensusConfig;

let config = ConsensusConfig::builder()
    .heartbeat_interval(Duration::from_millis(250))
    .election_timeout(Duration::from_secs(1))
    .build()
    .unwrap();</code></pre>
<h3 id="leadership-deprioritization"><a class="header" href="#leadership-deprioritization">Leadership deprioritization</a></h3>
<pre><code class="language-rust ignore">let config = ConsensusConfig::default().deprioritize_leadership();</code></pre>
<p>This multiplies the election timeout by a factor, making this node less likely
to become leader. Used by collection readers.</p>
<hr>
<h2 id="syncconfig-collections"><a class="header" href="#syncconfig-collections"><code>SyncConfig</code> (collections)</a></h2>
<p>Controls snapshot-based state synchronization for collections.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fetch_batch_size</code></td><td><code>usize</code></td><td><code>2000</code></td><td>Max items per batch request</td></tr>
<tr><td><code>snapshot_ttl</code></td><td><code>Duration</code></td><td><code>10s</code></td><td>How long a snapshot remains available</td></tr>
<tr><td><code>snapshot_request_timeout</code></td><td><code>Duration</code></td><td><code>15s</code></td><td>Timeout for requesting a snapshot</td></tr>
<tr><td><code>fetch_timeout</code></td><td><code>Duration</code></td><td><code>5s</code></td><td>Timeout for each batch fetch</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="configuration-hierarchy"><a class="header" href="#configuration-hierarchy">Configuration hierarchy</a></h2>
<pre><code class="language-text">NetworkBuilder
├── network_id          (identity)
├── secret_key          (identity)
├── relay_mode          (transport)
├── mdns_discovery      (transport)
├── addresses           (transport)
│
├── discovery::Config
│   ├── bootstrap_peers
│   ├── tags
│   ├── events_backlog
│   ├── purge_after
│   ├── max_time_drift
│   ├── announce_interval
│   └── announce_jitter
│
├── streams::Config
│   └── backoff
│
└── groups::Config
    └── handshake_timeout

Per-group:
ConsensusConfig         (consensus timing, hashed into GroupId)

Per-collection:
SyncConfig              (state sync tuning)
</code></pre>
<h2 id="environment-influence"><a class="header" href="#environment-influence">Environment influence</a></h2>
<p>Configuration structs are pure Rust — there is no automatic environment
variable parsing. However, test utilities honor:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variable</th><th>Used by</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>TEST_TRACE</code></td><td>Test tracing setup</td><td>Controls log level (<code>debug</code>/<code>trace</code>/<code>info</code>/etc.)</td></tr>
<tr><td><code>TEST_TRACE_UNMUTE</code></td><td>Test tracing setup</td><td>Set to <code>1</code> to show all log output</td></tr>
<tr><td><code>TIME_FACTOR</code></td><td>Test time helpers</td><td>Float multiplier for all test durations</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h1>
<p>Mosaik uses typed error enums specific to each subsystem, plus a
close-reason system for QUIC connection-level codes. This chapter catalogs
every public error type.</p>
<h2 id="network-errors"><a class="header" href="#network-errors">Network errors</a></h2>
<p><code>network::Error</code> — returned by <code>NetworkBuilder::build()</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MissingNetworkId</code></td><td>No <code>network_id</code> was set on the builder</td></tr>
<tr><td><code>Bind(BindError)</code></td><td>Failed to bind the QUIC endpoint</td></tr>
<tr><td><code>InvalidAddress(InvalidSocketAddr)</code></td><td>An address in <code>addresses</code> is invalid</td></tr>
<tr><td><code>DiscoveryConfig(ConfigBuilderError)</code></td><td>Discovery config builder failed validation</td></tr>
<tr><td><code>StreamsConfig(ConfigBuilderError)</code></td><td>Streams config builder failed validation</td></tr>
<tr><td><code>GroupsConfig(ConfigBuilderError)</code></td><td>Groups config builder failed validation</td></tr>
</tbody>
</table>
</div>
<h2 id="discovery-errors"><a class="header" href="#discovery-errors">Discovery errors</a></h2>
<p><code>discovery::Error</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>InvalidSecretKey(PeerId, PeerId)</code></td><td>Secret key does not match expected <code>PeerId</code></td></tr>
<tr><td><code>DifferentNetwork { local_network, remote_network }</code></td><td>Remote peer is on a different network</td></tr>
<tr><td><code>InvalidSignature</code></td><td>Peer entry signature verification failed</td></tr>
<tr><td><code>GossipJoin(ApiError)</code></td><td>Failed to join gossip topic (iroh_gossip)</td></tr>
<tr><td><code>PeerIdChanged(PeerId, PeerId)</code></td><td>Attempted to change the local peer’s ID</td></tr>
<tr><td><code>Link(LinkError)</code></td><td>Transport-level link error</td></tr>
<tr><td><code>Other(Box&lt;dyn Error&gt;)</code></td><td>Generic boxed error</td></tr>
<tr><td><code>Cancelled</code></td><td>Operation was cancelled</td></tr>
</tbody>
</table>
</div>
<h2 id="command-errors-1"><a class="header" href="#command-errors-1">Command errors</a></h2>
<p><code>groups::CommandError&lt;M&gt;</code> — returned by <code>execute()</code>, <code>execute_many()</code>,
<code>feed()</code>, <code>feed_many()</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Recoverable?</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Offline(Vec&lt;M::Command&gt;)</code></td><td><strong>Yes</strong></td><td>Node is offline; carries the unsent commands for retry</td></tr>
<tr><td><code>NoCommands</code></td><td>No</td><td>Empty command batch was submitted</td></tr>
<tr><td><code>GroupTerminated</code></td><td>No</td><td>The group has been permanently closed</td></tr>
</tbody>
</table>
</div>
<h3 id="recovering-from-offline"><a class="header" href="#recovering-from-offline">Recovering from <code>Offline</code></a></h3>
<pre><code class="language-rust ignore">match group.execute(MyCommand::Increment).await {
    Ok(result) =&gt; println!("committed: {result:?}"),
    Err(CommandError::Offline(commands)) =&gt; {
        // Wait for the group to come online, then retry
        group.when().online().await;
        for cmd in commands {
            group.execute(cmd).await?;
        }
    }
    Err(CommandError::GroupTerminated) =&gt; {
        // Permanent failure — stop trying
    }
    Err(CommandError::NoCommands) =&gt; unreachable!(),
}</code></pre>
<h2 id="query-errors-1"><a class="header" href="#query-errors-1">Query errors</a></h2>
<p><code>groups::QueryError&lt;M&gt;</code> — returned by <code>query()</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Recoverable?</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Offline(M::Query)</code></td><td><strong>Yes</strong></td><td>Node is offline; carries the unsent query</td></tr>
<tr><td><code>GroupTerminated</code></td><td>No</td><td>The group has been permanently closed</td></tr>
</tbody>
</table>
</div>
<h2 id="collection-errors"><a class="header" href="#collection-errors">Collection errors</a></h2>
<p><code>collections::Error&lt;T&gt;</code> — returned by collection write operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Recoverable?</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Offline(T)</code></td><td><strong>Yes</strong></td><td>Node is offline; carries the value for retry</td></tr>
<tr><td><code>NetworkDown</code></td><td>No</td><td>Network has shut down</td></tr>
</tbody>
</table>
</div>
<p>The generic <code>T</code> contains the value that failed to be written, enabling retry
without re-creating the data:</p>
<pre><code class="language-rust ignore">match map.insert("key".into(), 42).await {
    Ok(prev) =&gt; println!("previous: {prev:?}"),
    Err(collections::Error::Offline(value)) =&gt; {
        // value == 42, retry later
    }
    Err(collections::Error::NetworkDown) =&gt; {
        // permanent failure
    }
}</code></pre>
<h2 id="producer-errors"><a class="header" href="#producer-errors">Producer errors</a></h2>
<p><code>streams::producer::Error&lt;D&gt;</code> — returned by <code>Sink::send()</code> and <code>try_send()</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Closed(Option&lt;D&gt;)</code></td><td>Producer has been closed</td></tr>
<tr><td><code>Full(D)</code></td><td>Internal buffer is full (back-pressure)</td></tr>
<tr><td><code>Offline(D)</code></td><td>No active consumers connected</td></tr>
</tbody>
</table>
</div>
<p>All variants carry the datum back when possible, enabling retry.</p>
<h2 id="close-reasons-quic-application-codes"><a class="header" href="#close-reasons-quic-application-codes">Close reasons (QUIC application codes)</a></h2>
<p>Mosaik uses typed <strong>close reasons</strong> for QUIC <code>ApplicationClose</code> codes. These
are generated with the <code>make_close_reason!</code> macro and appear in connection
close frames.</p>
<h3 id="reserved-ranges"><a class="header" href="#reserved-ranges">Reserved ranges</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Range</th><th>Owner</th></tr>
</thead>
<tbody>
<tr><td>0–199</td><td>mosaik internal</td></tr>
<tr><td>200+</td><td>Application-defined</td></tr>
</tbody>
</table>
</div>
<h3 id="built-in-close-reasons"><a class="header" href="#built-in-close-reasons">Built-in close reasons</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Code</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Success</code></td><td>200</td><td>Protocol completed successfully</td></tr>
<tr><td><code>GracefulShutdown</code></td><td>204</td><td>Graceful shutdown</td></tr>
<tr><td><code>InvalidAlpn</code></td><td>100</td><td>Wrong ALPN protocol</td></tr>
<tr><td><code>DifferentNetwork</code></td><td>101</td><td>Peer on a different network</td></tr>
<tr><td><code>Cancelled</code></td><td>102</td><td>Operation cancelled</td></tr>
<tr><td><code>UnexpectedClose</code></td><td>103</td><td>Unexpected connection close</td></tr>
<tr><td><code>ProtocolViolation</code></td><td>400</td><td>Protocol message violation</td></tr>
<tr><td><code>UnknownPeer</code></td><td>401</td><td>Peer not found in discovery catalog</td></tr>
</tbody>
</table>
</div>
<h3 id="group-close-reasons"><a class="header" href="#group-close-reasons">Group close reasons</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Code</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>InvalidHandshake</code></td><td>30,400</td><td>Handshake decode error</td></tr>
<tr><td><code>GroupNotFound</code></td><td>30,404</td><td>Unknown group ID</td></tr>
<tr><td><code>InvalidProof</code></td><td>30,405</td><td>Invalid authentication proof</td></tr>
<tr><td><code>Timeout</code></td><td>30,408</td><td>Peer response timeout</td></tr>
<tr><td><code>AlreadyBonded</code></td><td>30,429</td><td>Duplicate bond between peers</td></tr>
</tbody>
</table>
</div>
<h3 id="defining-custom-close-reasons"><a class="header" href="#defining-custom-close-reasons">Defining custom close reasons</a></h3>
<pre><code class="language-rust ignore">use mosaik::network::make_close_reason;

// Code must be &gt;= 200
make_close_reason!(MyAppError, 500, "Application-specific error");</code></pre>
<h2 id="error-design-patterns"><a class="header" href="#error-design-patterns">Error design patterns</a></h2>
<h3 id="temporary-vs-permanent"><a class="header" href="#temporary-vs-permanent">Temporary vs. permanent</a></h3>
<p>Mosaik errors follow a consistent pattern:</p>
<ul>
<li><strong>Temporary</strong> errors carry the original data back (e.g., <code>Offline(commands)</code>,
<code>Full(datum)</code>) so you can retry without data loss.</li>
<li><strong>Permanent</strong> errors (e.g., <code>GroupTerminated</code>, <code>NetworkDown</code>) indicate the
resource is gone and retrying is pointless.</li>
</ul>
<h3 id="matching-on-recoverability"><a class="header" href="#matching-on-recoverability">Matching on recoverability</a></h3>
<pre><code class="language-rust ignore">use mosaik::collections::Error;

loop {
    match map.insert("key".into(), value.clone()).await {
        Ok(_) =&gt; break,
        Err(Error::Offline(_)) =&gt; {
            map.when().online().await;
            continue;
        }
        Err(Error::NetworkDown) =&gt; {
            panic!("network is gone");
        }
    }
}</code></pre>
<h3 id="the-closereason-trait"><a class="header" href="#the-closereason-trait">The <code>CloseReason</code> trait</a></h3>
<p>All close reason types implement:</p>
<pre><code class="language-rust ignore">trait CloseReason:
    Error + Into&lt;ApplicationClose&gt; + PartialEq&lt;ApplicationClose&gt;
    + Clone + Send + Sync + 'static
{}</code></pre>
<p>This lets you match connection close frames against typed reasons:</p>
<pre><code class="language-rust ignore">if close_frame == InvalidProof {
    // handle proof failure
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="primitives-reference"><a class="header" href="#primitives-reference">Primitives Reference</a></h1>
<p>This chapter documents the foundational types and utilities that the rest of
mosaik builds on. These live in the <code>primitives</code> module (public types) and
internal helpers.</p>
<h2 id="digest--uniqueid--tag"><a class="header" href="#digest--uniqueid--tag"><code>Digest</code> / <code>UniqueId</code> / <code>Tag</code></a></h2>
<p>The core identifier type — a 32-byte blake3 hash.</p>
<pre><code class="language-rust ignore">use mosaik::Digest;  // re-exported at crate root</code></pre>
<p><code>Digest</code>, <code>UniqueId</code>, and <code>Tag</code> are all the same type, aliased for clarity in
different contexts:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Alias</th><th>Used for</th></tr>
</thead>
<tbody>
<tr><td><code>Digest</code></td><td>General-purpose 32-byte identifier</td></tr>
<tr><td><code>UniqueId</code></td><td>Derived identity (groups, stores, bonds)</td></tr>
<tr><td><code>Tag</code></td><td>Discovery tags for peer classification</td></tr>
<tr><td><code>NetworkId</code></td><td>Network identifier (<code>= Digest</code>)</td></tr>
<tr><td><code>GroupId</code></td><td>Group identifier (<code>= Digest</code>)</td></tr>
<tr><td><code>StreamId</code></td><td>Stream identifier (<code>= Digest</code>)</td></tr>
<tr><td><code>StoreId</code></td><td>Collection store identifier (<code>= UniqueId</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="construction-6"><a class="header" href="#construction-6">Construction</a></h3>
<pre><code class="language-rust ignore">// From a string (hashes the string with blake3)
let tag = Digest::from("validator");

// From a hex string (64 chars = direct decode, otherwise hashed)
let id = Digest::from("a1b2c3d4...");

// From numeric types (little-endian encoded, then hashed)
let id = Digest::from_u64(42);

// From multiple parts (concatenated, then hashed)
let id = Digest::from_parts(&amp;["prefix", "suffix"]);

// Derive a child ID deterministically
let child = parent.derive("child-name");

// Random
let id = Digest::random();

// Zero (sentinel value)
let zero = Digest::zero();</code></pre>
<h3 id="compile-time-construction"><a class="header" href="#compile-time-construction">Compile-time construction</a></h3>
<pre><code class="language-rust ignore">use mosaik::unique_id;

const MY_ID: UniqueId = unique_id!("a1b2c3d4e5f6...");  // 64-char hex literal</code></pre>
<h3 id="display"><a class="header" href="#display">Display</a></h3>
<ul>
<li><code>Display</code> — short hex (first 5 bytes): <code>a1b2c3d4e5</code></li>
<li><code>Debug</code> — full 64-character hex string</li>
<li><code>Short&lt;T&gt;</code> wrapper — always shows first 5 bytes</li>
<li><code>Abbreviated&lt;const LEN, T&gt;</code> — shows <code>first..last</code> if longer than LEN</li>
</ul>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<ul>
<li><strong>Human-readable</strong> formats (JSON, TOML): hex string</li>
<li><strong>Binary</strong> formats (postcard): raw 32 bytes</li>
</ul>
<hr>
<h2 id="peerid"><a class="header" href="#peerid"><code>PeerId</code></a></h2>
<pre><code class="language-rust ignore">type PeerId = iroh::EndpointId;</code></pre>
<p>A peer’s public identity, derived from their Ed25519 public key. This is an
iroh type, not a mosaik <code>Digest</code>. It is used in discovery, bonds, and
connection authentication.</p>
<h2 id="secretkey"><a class="header" href="#secretkey"><code>SecretKey</code></a></h2>
<p>Re-exported from iroh. An Ed25519 secret key that determines a node’s
<code>PeerId</code>. If not provided to <code>NetworkBuilder</code>, a random key is generated
automatically — this is the recommended default for regular nodes.</p>
<p>Specifying a fixed secret key is only recommended for <strong>bootstrap nodes</strong>
that need a stable, well-known peer ID across restarts:</p>
<pre><code class="language-rust ignore">use mosaik::SecretKey;

// Auto-generated (default) — new identity each run
let network = Network::builder()
    .network_id("my-network")
    .build().await?;

// Fixed key — stable identity, recommended only for bootstrap nodes
let key = SecretKey::generate(&amp;mut rand::rng());
let bootstrap = Network::builder()
    .network_id("my-network")
    .secret_key(key)
    .build().await?;</code></pre>
<hr>
<h2 id="wire-encoding"><a class="header" href="#wire-encoding">Wire encoding</a></h2>
<p>All network messages use <strong>postcard</strong> — a compact, <code>#[no_std]</code>-compatible
binary format using variable-length integers.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>serialize&lt;T: Serialize&gt;(&amp;T) -&gt; Bytes</code></td><td>Serialize to bytes (panics on failure)</td></tr>
<tr><td><code>deserialize&lt;T: DeserializeOwned&gt;(impl AsRef&lt;[u8]&gt;) -&gt; Result&lt;T&gt;</code></td><td>Deserialize from bytes</td></tr>
</tbody>
</table>
</div>
<p>These are internal crate functions. Application code interacts with them
indirectly through <code>Link&lt;P&gt;</code> send/receive and collection operations.</p>
<hr>
<h2 id="bytes--bytesmut"><a class="header" href="#bytes--bytesmut"><code>Bytes</code> / <code>BytesMut</code></a></h2>
<p>Re-exported from the <code>bytes</code> crate. Used throughout mosaik for zero-copy
byte buffers:</p>
<pre><code class="language-rust ignore">use mosaik::Bytes;

let data: Bytes = serialize(&amp;my_message);</code></pre>
<hr>
<h2 id="backofffactory"><a class="header" href="#backofffactory"><code>BackoffFactory</code></a></h2>
<p>A factory type for creating retry backoff strategies:</p>
<pre><code class="language-rust ignore">type BackoffFactory = Arc&lt;
    dyn Fn() -&gt; Box&lt;dyn Backoff + Send + Sync + 'static&gt;
        + Send + Sync + 'static
&gt;;</code></pre>
<p>Used in <code>streams::Config</code> to configure consumer reconnection. The <code>backoff</code>
crate is re-exported at <code>mosaik::streams::backoff</code>.</p>
<hr>
<h2 id="formatting-utilities"><a class="header" href="#formatting-utilities">Formatting utilities</a></h2>
<p>Internal helpers for consistent debug output:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Pretty&lt;T&gt;</code></td><td>Pass-through wrapper (for trait integration)</td></tr>
<tr><td><code>Short&lt;T&gt;</code></td><td>Display first 5 bytes as hex</td></tr>
<tr><td><code>Abbreviated&lt;const LEN, T&gt;</code></td><td>Show <code>first..last</code> hex if longer than LEN bytes</td></tr>
<tr><td><code>Redacted&lt;T&gt;</code></td><td>Always prints <code>&lt;redacted&gt;</code></td></tr>
<tr><td><code>FmtIter&lt;W, I&gt;</code></td><td>Format iterator elements comma-separated in brackets</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="intoiterorsinglet"><a class="header" href="#intoiterorsinglet"><code>IntoIterOrSingle&lt;T&gt;</code></a></h2>
<p>An ergonomic trait that lets API methods accept either a single item or an
iterator:</p>
<pre><code class="language-rust ignore">// Both work:
discovery.with_tags("validator");            // single tag
discovery.with_tags(["validator", "relay"]); // multiple tags</code></pre>
<p>This is implemented via two blanket impls using <code>Variant&lt;0&gt;</code> (single item
via <code>Into&lt;T&gt;</code>) and <code>Variant&lt;1&gt;</code> (iterator of <code>Into&lt;T&gt;</code>).</p>
<hr>
<h2 id="internal-async-primitives"><a class="header" href="#internal-async-primitives">Internal async primitives</a></h2>
<p>These are <code>pub(crate)</code> and not part of the public API, but understanding them
helps when reading mosaik’s source code.</p>
<h3 id="unboundedchannelt"><a class="header" href="#unboundedchannelt"><code>UnboundedChannel&lt;T&gt;</code></a></h3>
<p>A wrapper around <code>tokio::sync::mpsc::unbounded_channel</code> that keeps both the
sender and receiver in one struct:</p>
<pre><code class="language-rust ignore">let channel = UnboundedChannel::new();
channel.send(42);
let val = channel.recv().await;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sender()</code></td><td>Get <code>&amp;UnboundedSender&lt;T&gt;</code></td></tr>
<tr><td><code>receiver()</code></td><td>Get <code>&amp;mut UnboundedReceiver&lt;T&gt;</code></td></tr>
<tr><td><code>send(T)</code></td><td>Send (errors silently ignored)</td></tr>
<tr><td><code>recv()</code></td><td>Async receive</td></tr>
<tr><td><code>poll_recv(cx)</code></td><td>Poll-based receive</td></tr>
<tr><td><code>poll_recv_many(cx, buf, limit)</code></td><td>Batch poll receive</td></tr>
<tr><td><code>is_empty()</code> / <code>len()</code></td><td>Queue inspection</td></tr>
</tbody>
</table>
</div>
<h3 id="asyncworkqueuet"><a class="header" href="#asyncworkqueuet"><code>AsyncWorkQueue&lt;T&gt;</code></a></h3>
<p>A <code>FuturesUnordered</code> wrapper with a permanently-pending sentinel future so
that polling never returns <code>None</code>:</p>
<pre><code class="language-rust ignore">let queue = AsyncWorkQueue::new();
queue.enqueue(async { do_work().await });

// Poll via Stream trait — never completes while empty
while let Some(result) = queue.next().await {
    handle(result);
}</code></pre>
<h3 id="boxpinfutt"><a class="header" href="#boxpinfutt"><code>BoxPinFut&lt;T&gt;</code></a></h3>
<p>Type alias for boxed, pinned, send futures:</p>
<pre><code class="language-rust ignore">type BoxPinFut&lt;T&gt; = Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + 'static&gt;&gt;;</code></pre>
<p>The <code>InternalFutureExt</code> trait adds a <code>.pin()</code> method to any
<code>Future + Send + 'static</code> for ergonomic boxing.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p>This chapter covers how to test mosaik applications and how to work with
mosaik’s own test infrastructure when contributing.</p>
<h2 id="test-setup"><a class="header" href="#test-setup">Test setup</a></h2>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Add these to your <code>[dev-dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
mosaik = { version = "0.2" }
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
</code></pre>
<h3 id="basic-test-structure"><a class="header" href="#basic-test-structure">Basic test structure</a></h3>
<p>Every mosaik test follows the same pattern:</p>
<ol>
<li>Create networks with in-process endpoints.</li>
<li>Connect them via <code>sync_with</code> (or mDNS for local tests).</li>
<li>Wait for discovery to propagate.</li>
<li>Exercise the API.</li>
<li>Assert state.</li>
</ol>
<pre><code class="language-rust ignore">#[tokio::test]
async fn two_nodes_discover_each_other() {
    let net_a = Network::builder()
        .network_id("test")
        .build()
        .await
        .unwrap();

    let net_b = Network::builder()
        .network_id("test")
        .build()
        .await
        .unwrap();

    // Connect the two endpoints directly
    net_a.sync_with(net_b.endpoint_addr()).await.unwrap();

    // Wait for mutual discovery
    let event = net_a.discovery().events().recv().await.unwrap();
    assert!(matches!(event, Event::Discovered { .. }));
}</code></pre>
<h2 id="connecting-test-networks"><a class="header" href="#connecting-test-networks">Connecting test networks</a></h2>
<h3 id="sync_with"><a class="header" href="#sync_with"><code>sync_with</code></a></h3>
<p>The simplest way to connect two test nodes:</p>
<pre><code class="language-rust ignore">net_a.sync_with(net_b.endpoint_addr()).await?;</code></pre>
<p>This synchronizes discovery catalogs between the two nodes, establishing
mutual awareness.</p>
<h3 id="discover-all-fan-out"><a class="header" href="#discover-all-fan-out">Discover all (fan-out)</a></h3>
<p>For multi-node tests, connect all pairs:</p>
<pre><code class="language-rust ignore">async fn discover_all(networks: &amp;[&amp;Network]) {
    let futs: Vec&lt;_&gt; = networks.iter()
        .flat_map(|a| networks.iter().map(move |b| {
            a.sync_with(b.endpoint_addr())
        }))
        .collect();
    futures::future::try_join_all(futs).await.unwrap();
}</code></pre>
<p>Mosaik’s test suite provides this as a utility function.</p>
<h2 id="time-management"><a class="header" href="#time-management">Time management</a></h2>
<h3 id="time_factor-environment-variable"><a class="header" href="#time_factor-environment-variable"><code>TIME_FACTOR</code> environment variable</a></h3>
<p>All test durations are multiplied by <code>TIME_FACTOR</code> (default <code>1.0</code>). This is
useful for running tests on slow CI machines or over high-latency networks:</p>
<pre><code class="language-bash"># Double all timeouts for slow CI
TIME_FACTOR=2.0 cargo test

# 10x for debugging with breakpoints
TIME_FACTOR=10.0 cargo test -- --nocapture
</code></pre>
<h3 id="time-helper-functions"><a class="header" href="#time-helper-functions">Time helper functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>secs(n)</code></td><td><code>Duration::from_secs(n) × TIME_FACTOR</code></td></tr>
<tr><td><code>millis(n)</code></td><td><code>Duration::from_millis(n) × TIME_FACTOR</code></td></tr>
<tr><td><code>sleep_s(n)</code></td><td><code>tokio::time::sleep(secs(n))</code></td></tr>
<tr><td><code>sleep_ms(n)</code></td><td><code>tokio::time::sleep(millis(n))</code></td></tr>
<tr><td><code>timeout_s(n, fut)</code></td><td>Timeout with location tracking</td></tr>
<tr><td><code>timeout_ms(n, fut)</code></td><td>Timeout with location tracking</td></tr>
</tbody>
</table>
</div>
<p>The <code>timeout_*</code> functions use <code>#[track_caller]</code> so timeout errors report the
<strong>test</strong> line number, not the utility function.</p>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<h3 id="automatic-initialization"><a class="header" href="#automatic-initialization">Automatic initialization</a></h3>
<p>Mosaik’s test suite uses <code>#[ctor::ctor]</code> to initialize tracing before any test
runs. Control it with environment variables:</p>
<pre><code class="language-bash"># Enable debug logging
TEST_TRACE=debug cargo test

# Available levels: trace, debug, info, warn, error
TEST_TRACE=trace cargo test -- test_name

# Show all modules (including noisy deps)
TEST_TRACE=debug TEST_TRACE_UNMUTE=1 cargo test
</code></pre>
<h3 id="muted-modules"><a class="header" href="#muted-modules">Muted modules</a></h3>
<p>By default, these noisy modules are filtered out:</p>
<ul>
<li><code>iroh</code>, <code>rustls</code>, <code>igd_next</code>, <code>hickory_*</code></li>
<li><code>hyper_util</code>, <code>portmapper</code>, <code>reqwest</code></li>
<li><code>netwatch</code>, <code>mio</code>, <code>acto</code>, <code>swarm_discovery</code></li>
<li><code>events.net.relay.connected</code></li>
</ul>
<p>Set <code>TEST_TRACE_UNMUTE=1</code> to see their output.</p>
<h3 id="panic-handling"><a class="header" href="#panic-handling">Panic handling</a></h3>
<p>The test harness installs a custom panic hook that:</p>
<ol>
<li>Logs the panic via <code>tracing::error!</code>.</li>
<li>Calls <code>std::process::abort()</code> to prevent test framework from masking the
panic in async contexts.</li>
</ol>
<h2 id="testing-patterns"><a class="header" href="#testing-patterns">Testing patterns</a></h2>
<h3 id="waiting-for-conditions"><a class="header" href="#waiting-for-conditions">Waiting for conditions</a></h3>
<p>Use the <code>When</code> API instead of arbitrary sleeps:</p>
<pre><code class="language-rust ignore">// Wait for a group to come online
group.when().online().await;

// Wait for a collection to reach a version
map.when().updated(|v| v.index() &gt;= 10).await;

// Wait for bonds to form
group.when().bonds(|b| b.len() &gt;= 2).await;</code></pre>
<h3 id="testing-state-machines"><a class="header" href="#testing-state-machines">Testing state machines</a></h3>
<p>Test your state machine in isolation before running it in a group:</p>
<pre><code class="language-rust ignore">#[test]
fn state_machine_logic() {
    let mut sm = Counter::default();
    let ctx = ApplyContext {
        index: 1,
        term: 1,
        leader: false,
    };

    let result = sm.apply(CounterCommand::Increment, ctx);
    assert_eq!(result, 0); // returns previous value

    let result = sm.apply(CounterCommand::Increment, ctx);
    assert_eq!(result, 1);
}</code></pre>
<h3 id="testing-collections"><a class="header" href="#testing-collections">Testing collections</a></h3>
<pre><code class="language-rust ignore">#[tokio::test]
async fn replicated_map() {
    let (net_a, net_b) = create_connected_pair().await;

    let writer: MapWriter&lt;String, u64&gt; = net_a.collections()
        .map_writer("my-store")
        .build();

    let reader: MapReader&lt;String, u64&gt; = net_b.collections()
        .map_reader("my-store")
        .build();

    // Write on node A
    writer.insert("key".into(), 42).await.unwrap();

    // Wait for replication on node B
    reader.when().updated(|v| v.index() &gt;= 1).await;

    // Read on node B
    assert_eq!(reader.get(&amp;"key".into()), Some(42));
}</code></pre>
<h3 id="testing-streams"><a class="header" href="#testing-streams">Testing streams</a></h3>
<pre><code class="language-rust ignore">#[tokio::test]
async fn stream_delivery() {
    let (net_a, net_b) = create_connected_pair().await;

    let producer = net_a.streams()
        .producer::&lt;Message&gt;("topic")
        .build();

    let consumer = net_b.streams()
        .consumer::&lt;Message&gt;("topic")
        .build();

    // Wait for consumer to connect
    producer.when().active().await;

    // Send and receive
    producer.send(Message("hello".into())).await.unwrap();
    let msg = consumer.recv().await.unwrap();
    assert_eq!(msg.0, "hello");
}</code></pre>
<h2 id="polling-futures-in-tests"><a class="header" href="#polling-futures-in-tests">Polling futures in tests</a></h2>
<p>For testing poll-based logic:</p>
<pre><code class="language-rust ignore">use std::task::Poll;

/// Poll a future exactly once with a no-op waker
fn poll_once&lt;F: Future + Unpin&gt;(f: &amp;mut F) -&gt; Poll&lt;F::Output&gt; {
    let waker = futures::task::noop_waker();
    let mut cx = std::task::Context::from_waker(&amp;waker);
    Pin::new(f).poll(&amp;mut cx)
}</code></pre>
<h2 id="ci-considerations"><a class="header" href="#ci-considerations">CI considerations</a></h2>
<ul>
<li>Set <code>TIME_FACTOR=2.0</code> or higher for CI environments.</li>
<li>Use <code>TEST_TRACE=debug</code> to capture logs on failure.</li>
<li>Run tests with <code>--test-threads=1</code> if you encounter port conflicts.</li>
<li>The test suite uses real networking (loopback), so ensure localhost UDP is
available.</li>
</ul>
<h2 id="project-test-structure"><a class="header" href="#project-test-structure">Project test structure</a></h2>
<pre><code class="language-text">tests/
├── basic.rs            # Test harness, data types, module declarations
├── collections/        # Map, Vec, Set, DEPQ tests
├── discovery/          # Catalog, departure tests
├── groups/             # Bonds, builder, execute, feed, leader, catchup
├── streams/            # Smoke tests, stats, producer/consumer
└── utils/
    ├── mod.rs          # discover_all helper
    ├── tracing.rs      # Auto-init tracing with ctor
    ├── time.rs         # TIME_FACTOR-aware duration helpers
    └── fut.rs          # poll_once, forever
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
